package edu.joshuacrotts.littlec.mipsgen;

import java.util.LinkedList;
import java.util.List;

import edu.joshuacrotts.littlec.icode.FunctionBlock;
import edu.joshuacrotts.littlec.icode.ICode;
import edu.joshuacrotts.littlec.icode.StringEntry;

/**
 * The top-level class for generating MIPS target code from intermediate-code.
 * The constructor does all the work, and "toString" gives a string/printable
 * representation.
 * 
 * @author Joshua Crotts
 */
public class MIPSGen {

  /** List of function blocks generated by the intermediate code. */
  private static List<FunctionBlock> functionBlocks;

  /** String of assembly instructions for output. */
  private StringBuilder mipsString;

  public MIPSGen(ICode iCode) {
    this.mipsString = new StringBuilder();
    this.mipsString.append(MIPSReg.stdFunctions());
    MIPSGen.functionBlocks = ICode.quad.generateFunctionBlocks();

    this.genMIPS();
  }

  /**
   * Generates the MIPS code for all three-address instructions.
   * 
   * @param void.
   * 
   * @return void.
   */
  private void genMIPS() {
    // First, we generate the function blocks. Then, we can go
    // inside and generate the MIPS code for each individually.
    for (int i = 0; i < functionBlocks.size(); i++) {
      MIPSFunction mipsFunc = new MIPSFunction(functionBlocks.get(i));
      this.mipsString.append(mipsFunc.genMIPS());
      this.mipsString.append("\n");
    }

    // Now append the data - start with the string table.
    this.mipsString.append("\t.data\n");
    this.genMIPSStrings();
    this.mipsString.append("\n");
    // Now append the global variables.
    this.genMIPSGlobals();
  }

  /**
   * Generates the string literal declarations used in the .data
   * segment of the code.
   * 
   * @param void.
   * 
   * @return void.
   */
  private void genMIPSStrings() {
    for (StringEntry se : ICode.getTopAR().getStringTable()) {
      this.mipsString.append(se.getMIPSCode());
      this.mipsString.append("\n");
    }
  }

  /**
   * Generates all global variables - both arrays and non-arrays.
   * We convert the .db/.dw into .byte/.word respectively, then either
   * add the value, or the size of the array. If it's an array, we then
   * populate it with the chars used (if it's a char and it's initialized)
   * OR we pad it with zeroes.
   * 
   * @param void.
   * 
   * @return void.
   */
  private void genMIPSGlobals() {
    LinkedList<LinkedList<String>> globals = ICode.quad.getGlobalVariableDeclarations();
    for (LinkedList<String> globalL : globals) {
      // Get the type (.db/dw).
      String type = globalL.get(1);
      // Start of global declaration.
      if (type.contains(".dw") || type.contains(".db")) {
        type = type.replaceAll(".db", ".byte");
        type = type.replace(".dw", ".word");
        // Append the compiler-generated label.
        this.mipsString.append(globalL.get(0) + ":\t");
        this.mipsString.append(type);
        this.mipsString.append(" ");
        this.mipsString.append(globalL.get(2));
      } else {
        // Array population.
        type = globalL.get(0);
        type = type.replaceAll(".db", ".byte");
        type = type.replace(".dw", ".word");

        // Using this operator, we populate X zeroes.
        if (type.contains("#")) {
          this.mipsString.append(type.subSequence(0, 5));
          this.mipsString.append(" ");
          String szIdx = type.substring(type.indexOf("#") + 1);
          int zeroCount = Integer.parseInt(szIdx);
          for (int i = 0; i < zeroCount - 1; i++) {
            this.mipsString.append("0, ");
          }
          this.mipsString.append("0");
        } else {
          this.mipsString.append(type);
          this.mipsString.append(" ");
        }
      }
      this.mipsString.append("\n");
    }
  }

  @Override
  public String toString() {
    // Should convert whatever your internal MIPS-code representation is
    // into a string that is compatible with SPIM.
    return MIPSOptimizer.optimize(this.mipsString.toString());
  }
}