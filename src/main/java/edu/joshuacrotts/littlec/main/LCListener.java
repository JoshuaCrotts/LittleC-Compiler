package edu.joshuacrotts.littlec.main;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Stack;

import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeProperty;
import org.antlr.v4.runtime.tree.TerminalNode;

import edu.joshuacrotts.littlec.antlr4.LittleCBaseListener;
import edu.joshuacrotts.littlec.antlr4.LittleCLexer;
import edu.joshuacrotts.littlec.antlr4.LittleCParser;
import edu.joshuacrotts.littlec.antlr4.LittleCParser.ExprContext;
import edu.joshuacrotts.littlec.antlr4.LittleCParser.RuleFunctionDeclarationParametersContext;
import edu.joshuacrotts.littlec.syntaxtree.LCArrayIndexNode;
import edu.joshuacrotts.littlec.syntaxtree.LCAssignmentNode;
import edu.joshuacrotts.littlec.syntaxtree.LCBinaryOperatorNode;
import edu.joshuacrotts.littlec.syntaxtree.LCBreakStatementNode;
import edu.joshuacrotts.littlec.syntaxtree.LCConstantLiteralNode;
import edu.joshuacrotts.littlec.syntaxtree.LCFunctionArgsListNode;
import edu.joshuacrotts.littlec.syntaxtree.LCFunctionCallNode;
import edu.joshuacrotts.littlec.syntaxtree.LCFunctionDefinitionNode;
import edu.joshuacrotts.littlec.syntaxtree.LCFunctionPrototypeNode;
import edu.joshuacrotts.littlec.syntaxtree.LCIfStatementNode;
import edu.joshuacrotts.littlec.syntaxtree.LCLoopStatementNode;
import edu.joshuacrotts.littlec.syntaxtree.LCPrePostOperatorNode;
import edu.joshuacrotts.littlec.syntaxtree.LCReturnStatementNode;
import edu.joshuacrotts.littlec.syntaxtree.LCSyntaxTree;
import edu.joshuacrotts.littlec.syntaxtree.LCUnaryOperatorNode;
import edu.joshuacrotts.littlec.syntaxtree.LCVariableDeclarationNode;
import edu.joshuacrotts.littlec.syntaxtree.LCVariableIdentifierNode;

/**
 * This class will contain all of your listener methods, which are called every
 * time a rule is entered or exited during parsing. This is what ties your
 * LittleC.g4 grammar file to your syntax tree creation methods.
 *
 * You can decide what listeners you need, and how to structure your code, but
 * you must provide the methods shown below.
 */
public class LCListener extends LittleCBaseListener {

  /**
   * Map for storing nodes for later lookup.
   */
  private final ParseTreeProperty<LCSyntaxTree> values;

  /**
   * Default LittleCParser object generated by ANTLR.
   */
  private LittleCParser parser;

  /**
   * Symbol table for the IDs and types of all variables and functions.
   */
  private SymbolTable symbolTable;

  /**
   * Syntax tree generated for traversal.
   */
  private LCSyntaxTree syntaxTree;

  /**
   * Way to keep track of the current syntax tree to append nodes to if we go into
   * a different scope. This is useful for when we reassign the scope for a
   * function, if statement, while or for loop.
   */
  private Stack<LCSyntaxTree> syntaxTreeScopes;

  /**
   * Keeps track of the current function's return type.
   */
  private String functionReturnType;

  /**
   * Keeps track of the current number of nested functions we have.
   */
  private int functionScopeCount = 0;

  /**
   * Keeps track of nested for/while loop scopes.
   */
  private int loopScopeCount = 0;

  /**
   * Keeps track of how many nested assignment expressions we have.
   */
  private int assignScopeCount = 0;

  /**
   * This constructor is expected by ParserTest, and so needs to be defined.
   * Initializes the syntax tree node, the scopes stack, and the symbol table.
   * 
   * @param parser - the parser class generated from ANTLR.
   */
  public LCListener(LittleCParser parser) {
    this.parser = parser;
    this.syntaxTree = new LCSyntaxTree();
    this.syntaxTreeScopes = new Stack<>();
    this.symbolTable = new SymbolTable();
    this.symbolTable.addEnvironment();
    this.values = new ParseTreeProperty<>();
    this.addDefaultGlobalFunctions();
  }

// ======================== STATEMENTS ===============================//

  /**
   * Enter new block scope. A new block is defined by a set of opening and closing
   * braces. It's akin to a mini program within the program.
   */
  @Override
  public void enterNewBlock(LittleCParser.NewBlockContext ctx) {
    // We need to create a new LCSyntaxTree to add to the fnDefNode so it makes a
    // new scope.
    LCSyntaxTree newScope = new LCSyntaxTree();
    this.syntaxTree.addChild(newScope);

    // We push the current syntaxtree for traversal to the stack so we can save its
    // context.
    this.syntaxTreeScopes.push(this.syntaxTree);

    // Set the scope of the syntax tree to be this new one so variables can easily
    // add to it.
    this.syntaxTree = newScope;
    this.symbolTable.addEnvironment();
  }

  /**
   * Exiting a new block scope. Similar to leaving an if/while/for loop context.
   */
  public void exitNewBlock(LittleCParser.NewBlockContext ctx) {
    // Removes the current environment from the stack and the syntax tree scope is
    // appended back to the main tree.
    this.symbolTable.popEnvironment();
    this.syntaxTree = this.syntaxTreeScopes.pop();
  }

  /**
   * Enter if statement context listener.
   */
  @Override
  public void enterIfStatement(LittleCParser.IfStatementContext ctx) {
    this.syntaxTree.setFlags(LCMasks.IF_MASK);
  }

  /**
   * Exit if statement context listener.
   */
  @Override
  public void exitIfStatement(LittleCParser.IfStatementContext ctx) {
    if (LCErrorListener.sawError())
      return;
    LCSyntaxTree condPortion = this.values.get(ctx.ruleIfStatementCond());
    LCSyntaxTree thenPortion = this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);
    LCSyntaxTree elsePortion = this.values.get(ctx.ruleElseStatement());

    this.syntaxTree.addChild(new LCIfStatementNode(ctx, condPortion, thenPortion, elsePortion));
    this.syntaxTree.turnOffFlags(LCMasks.IF_MASK);
  }

  /**
   * Enter if statement conditional context. This is unused.
   */
  @Override
  public void enterIfStatementConditional(LittleCParser.IfStatementConditionalContext ctx) {
    this.syntaxTree.setFlags(LCMasks.COND_MASK);
  }

  /**
   * Exit if statement conditional context. Since expressions and function calls
   * can be used in an if statement conditional, we need to determine when we
   * enter/exit one.
   */
  @Override
  public void exitIfStatementConditional(LittleCParser.IfStatementConditionalContext ctx) {
    this.values.put(ctx, this.values.get(ctx.expr()));
    this.syntaxTree.turnOffFlags(LCMasks.COND_MASK);
  }

  /**
   * Enter else statement listener. If we are using a multi-line else statement
   * (i.e. braces are used), then we create a new syntaxtree and save the old one
   * so we can come back to it.
   */
  @Override
  public void enterElseStatement(LittleCParser.ElseStatementContext ctx) {
  }

  /**
   * Exit else statement context listener. Else statements are optional.
   */
  @Override
  public void exitElseStatement(LittleCParser.ElseStatementContext ctx) {
    if (this.syntaxTree.getChildren().isEmpty()) {
      return;
    }

    LCSyntaxTree lastChild = this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);
    this.values.put(ctx, lastChild);
  }

  /**
   * Enter while statement context listener. A new syntax tree scope is pushed to
   * store all newly-created nodes in this new block.
   */
  @Override
  public void enterWhileStatement(LittleCParser.WhileStatementContext ctx) {
    this.syntaxTree.setFlags(LCMasks.LOOP_MASK);
    this.loopScopeCount++;
  }

  /**
   * Exit while statement context listener. This is replicated for the for loop
   * minus a few pieces.
   */
  @Override
  public void exitWhileStatement(LittleCParser.WhileStatementContext ctx) {
    if (this.syntaxTree.getChildren().isEmpty()) {
      return;
    }

    // The last-added child is whatever comes directly after the while cond part so
    // we can just remove it from the main tree and add it to the cond tree.
    LCSyntaxTree loopBody = this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);
    LCSyntaxTree condPortion = this.values.get(ctx.ruleWhileStatementCond());
    this.syntaxTree.addChild(new LCLoopStatementNode(ctx, condPortion, loopBody));

    // Turn off the flag for being in a loop.
    this.syntaxTree.turnOffFlags(LCMasks.LOOP_MASK);
    this.loopScopeCount--;
  }

  /**
   * Enter while statement conditional context. This is unused.
   */
  @Override
  public void enterWhileStatementConditional(LittleCParser.WhileStatementConditionalContext ctx) {
    this.syntaxTree.setFlags(LCMasks.COND_MASK);
  }

  /**
   * Exit while statement conditional context. If there are multiple lines to this
   * while loop, we set the flags and push a new ST.
   */
  @Override
  public void exitWhileStatementConditional(LittleCParser.WhileStatementConditionalContext ctx) {
    this.values.put(ctx, this.values.get(ctx.expr()));
    this.syntaxTree.turnOffFlags(LCMasks.COND_MASK);
  }

  /**
   * Enter for statement context listener. A new syntax tree scope is pushed to
   * store all newly-created nodes in this new block.
   */
  @Override
  public void enterForStatement(LittleCParser.ForStatementContext ctx) {
    this.syntaxTree.setFlags(LCMasks.LOOP_MASK);
    this.loopScopeCount++;
  }

  /**
   * Exit for statement context listener. The differnet pieces of the for loop are
   * constructed here. Some pieces of the for loop are located in the current
   * syntax tree, so those are removed and re-stored in the for loop construction
   * node.
   */
  @Override
  public void exitForStatement(LittleCParser.ForStatementContext ctx) {
    // The last-added child is whatever comes directly after the while cond part so
    // we can just remove it from the main tree and add it to the cond tree.
    LCSyntaxTree loopBody = this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);

    // First, we grab the saved expression.
    LCSyntaxTree loopInitializeExpression = this.values.get(ctx.expr(0));

    // Now grab the conditional portion.
    LCSyntaxTree loopTestExpression = this.values.get(ctx.ruleForStatementCond());

    // Finally, grab the update expression.
    LCSyntaxTree loopUpdateExpression = this.values.get(ctx.expr(1));

    // Remove the update expression from the current tree since we need to place it
    // in the new body.
    this.syntaxTree.getChildren().remove(loopUpdateExpression);

    // The outer body of the loop has the inner body as a seq and the update expr.
    LCSyntaxTree outerLoopBody = new LCSyntaxTree();
    outerLoopBody.addChild(loopBody);
    outerLoopBody.addChild(loopUpdateExpression);

    // Create a dummy tree to add our initialization expr to.
    LCSyntaxTree seqFor = new LCSyntaxTree();

    // Now add the sequence of for statements to the parent tree.
    seqFor.addChild(loopInitializeExpression);
    seqFor.addChild(new LCLoopStatementNode(ctx, loopTestExpression, outerLoopBody));

    // Now we append the corrected seqFor tree.
    this.syntaxTree.addChild(seqFor);

    // Turn off the flag for being in a loop.
    this.syntaxTree.turnOffFlags(LCMasks.LOOP_MASK);
    this.loopScopeCount--;
  }

  /**
   * Enter while statement conditional context. This is unused.
   */
  @Override
  public void enterForStatementConditional(LittleCParser.ForStatementConditionalContext ctx) {
    this.syntaxTree.setFlags(LCMasks.COND_MASK);
  }

  /**
   * For while statement conditional context. If there are multiple lines to this
   * while loop, we set the flags and push a new ST.
   */
  @Override
  public void exitForStatementConditional(LittleCParser.ForStatementConditionalContext ctx) {
    this.values.put(ctx, this.values.get(ctx.expr()));
    this.syntaxTree.turnOffFlags(LCMasks.COND_MASK);
  }

  /**
   * Break statement exit context listener. The verification for break statement
   * location is performed here.
   */
  @Override
  public void exitBreakStatement(LittleCParser.BreakStatementContext ctx) {
    LCBreakStatementNode breakStmt = new LCBreakStatementNode(ctx);

    // We have to make sure that we're actually inside of a loop to break.
    if (this.loopScopeCount > 0) {
      this.syntaxTree.addChild(breakStmt);
      this.values.put(ctx, breakStmt);
    } else {
      LCErrorListener.syntaxError(ctx, "break statement cannot be used outside a loop.");
    }
  }

  /**
   * Function prototype context exit listener. A function prototype is only added
   * to the symbol table in case a function uses it before the definition is
   * declared. This is just like a normal C function prototype.
   */
  @Override
  public void exitFunctionPrototype(LittleCParser.FunctionPrototypeContext ctx) {
    String id = ctx.ID().getText();
    String storageClass = LCUtilities.getStorageClassType(ctx.optStorageClass());
    int tokType = storageClass.equals("auto") ? 0 : 1;
    String retType = ctx.getChild(tokType).getText();

    if (!retType.equals("int") && !retType.equals("float") && !retType.equals("void") && !retType.equals("char")) {
      LCErrorListener.syntaxError(ctx, "return type is unspecified.");
      return;
    }

    // We pull in the ID and the datatype of the parameter in the prototype, and
    // store it in a HashMap.
    LinkedHashMap<String, String> args = new LinkedHashMap<String, String>();
    RuleFunctionDeclarationParametersContext p = ctx.ruleFunctionDeclarationParameters(0);
    final int SPACE_PER_ARG = 3; // Number of tokens in between arguments.
    if (p != null) {
      for (int i = 0; i < p.getChildCount(); i += SPACE_PER_ARG) {
        String varDatatype = p.getChild(i).getText();
        String varID = p.getChild(i + 1).getText();
        args.put(varID, varDatatype);
      }
    }

    // We DO NOT add this to the tree since a prototype is just a forward
    // declaration for the symbol table!
    LCFunctionPrototypeNode prototypeNode = new LCFunctionPrototypeNode(ctx, this.symbolTable, id, retType,
        storageClass, args);
    this.functionReturnType = retType;
    this.syntaxTree.clearFlags();
  }

  /**
   * Function call context exit.
   */
  @Override
  public void exitFunctionCallParameters(LittleCParser.FunctionCallParametersContext ctx) {
    // Build the list, then pass it to the arg node.
    LinkedList<LCSyntaxTree> argsList = new LinkedList<>();
    for (int i = 0; i < ctx.expr().size(); i++) {
      ExprContext exprCtx = ctx.expr(i);
      LCSyntaxTree param = this.values.get(exprCtx);
      argsList.add(param);
    }

    LCFunctionArgsListNode fnArgsList = new LCFunctionArgsListNode(symbolTable, argsList);
    this.values.put(ctx, fnArgsList);
  }

  /**
   * Function declaration listener. A function declaration is distinct from a
   * prototype.
   */
  @Override
  public void enterFunctionDeclaration(LittleCParser.FunctionDeclarationContext ctx) {
    String id = ctx.ID().getText();
    String storageClass = LCUtilities.getStorageClassType(ctx.optStorageClass());
    int tokType = storageClass.equals("auto") ? 0 : 1;
    String retType = ctx.getChild(tokType).getText();

    if (!retType.equals("int") && !retType.equals("float") && !retType.equals("void") && !retType.equals("char")) {
      LCErrorListener.syntaxError(ctx, "return type is unspecified.");
      return;
    }

    // The LinkedHashMap contains data types and IDs. Since we really only care
    // about the data type (but we have to store the IDs for the parse tree), and
    // the IDs must be unique, IDs are the key, and data types are the value. We use
    // a LinkedHashMap so the IDs are stored the same as they are entered.
    LinkedHashMap<String, String> args = new LinkedHashMap<String, String>();
    RuleFunctionDeclarationParametersContext p = ctx.ruleFunctionDeclarationParameters(0);
    final int SPACE_PER_ARG = 3; // Number of tokens in between arguments.
    if (p != null) {
      for (int i = 0; i < p.getChildCount(); i += SPACE_PER_ARG) {
        String varDatatype = p.getChild(i).getText();
        String varID = p.getChild(i + 1).getText();
        args.put(varID, varDatatype);
      }
    }

    // We need to create a new LCSyntaxTree to add to the fnDefNode so it makes a
    // new scope.
    LCSyntaxTree newScope = new LCSyntaxTree();
    LCFunctionDefinitionNode fnDefNode = new LCFunctionDefinitionNode(ctx, this.symbolTable, id, retType, storageClass,
        args, newScope);
    this.values.put(ctx, fnDefNode);
    this.syntaxTree.addChild(fnDefNode);
    this.functionReturnType = retType;

    // We push the current syntaxtree for traversal to the stack so we can save its
    // context.
    this.syntaxTreeScopes.push(this.syntaxTree);

    // Set the scope of the syntax tree to be this new one so variables can easily
    // add to it.
    this.syntaxTree = newScope;
  }

  /**
   * Exit function declaration context listener. The return verification is done
   * here (i.e. if a return statement is required, it is checked in this block).
   * The current environment in the symbol table stack is popped, and the stack
   * for the SyntaxTree nodes is reset.
   */
  @Override
  public void exitFunctionDeclaration(LittleCParser.FunctionDeclarationContext ctx) {
    if (LCErrorListener.sawError()) {
      return;
    }

    // Check the return type and verify that it exists if we have a non-void
    // function.
    if (!this.functionReturnType.equals("void")) {
      int seqSize = this.syntaxTree.getChildren().size();

      // If we don't have any children in the tree and we have a return type,
      // we throw an error.
      if (this.syntaxTree.getChildren().isEmpty()) {
        LCErrorListener.syntaxError(ctx, "missing required return statement at end of function " + ctx.ID() + ".");
        return;
      }

      LCSyntaxTree lastChild = this.syntaxTree.getChildren().get(seqSize - 1);

      // Case 1: If our last child is an if/else if chain, then BOTH have to have
      // returns.
      if (lastChild.getLabel().equals("IF")) {
        int ifSize = lastChild.getChildren().size();

        // If it's two then we have no else chain and we're already screwed.
        if (ifSize == 2) {
          LCErrorListener.syntaxError(ctx,
              "missing required return statement outside if in function " + ctx.ID() + ".");
          return;
        }

        // Grab the children making the if/else chain.
        // This is ALWAYS only the if statement.
        LCSyntaxTree ifChild = lastChild.getChildren().get(1);

        // This can be the single else, or a giant chain of else/ifs.
        LCSyntaxTree elseChild = lastChild.getChildren().get(2);

        // Now we can check if BOTH the if and else bodies have returns everywhere.
        boolean hasReturn = LCUtilities.hasReturn(ifChild) && LCUtilities.hasReturn(elseChild);
        if (!hasReturn) {
          LCErrorListener.syntaxError(ctx,
              "missing required return statement in if/else block in function " + ctx.ID() + ".");
        }

      }
      // Case 2: In this event, the last statement HAS to be a return.
      else if (!lastChild.getLabel().equals("RETURN")) {
        LCErrorListener.syntaxError(ctx, "missing required return statement at end of function " + ctx.ID() + ".");
      }
    }

    // Removes the current environment from the stack and the syntax tree scope is
    // appended back to the main tree.
    this.symbolTable.popEnvironment();
    this.syntaxTree = this.syntaxTreeScopes.pop();
    this.syntaxTree.clearFlags();
  }

  /**
   * Function call enter context.
   */
  @Override
  public void enterFunctionCall(LittleCParser.FunctionCallContext ctx) {
    String id = ctx.ID().getText();

    // If the function call is undefined.
    if (!symbolTable.hasSymbol(id)) {
      LCErrorListener.syntaxError(ctx, "function " + id + " definition not found; forward declaration not found.");
      return;
    }

    // If the symbol itself is defined but it's a variable then we can't use it.
    else if (symbolTable.hasSymbol(id) && symbolTable.getSymbolEntry(id).getType().equals("VAR")) {
      LCErrorListener.syntaxError(ctx, id + " is a variable and cannot be used as a function identifier.");
      return;
    }

    this.syntaxTree.setFlags(LCMasks.FUNCTION_CALL_MASK);
    this.functionScopeCount++;
  }

  /**
   * Function call exit listener.
   */
  @Override
  public void exitFunctionCall(LittleCParser.FunctionCallContext ctx) {
    if (LCErrorListener.sawError()) {
      return;
    }
    this.functionScopeCount--;
    String fnID = ctx.ID().getText();

    // Once we're out of the function call itself, we can actually put this node in
    // the tree and the map. This gets the function call parameters. If this is
    // null, we have no parameters.
    LCFunctionArgsListNode argsListNode = (LCFunctionArgsListNode) this.values.get(ctx.ruleFunctionCallParameters());
    LCFunctionCallNode fnCallNode = new LCFunctionCallNode(ctx, this.symbolTable, fnID, argsListNode);
    this.values.put(ctx, fnCallNode);

    // If we are not trying to assign the function to a variable (lvalue) AND we're
    // in the outer-most function (for composite function calls) AND we're not in a
    // return call, we can add it to the big tree.
    if (LCUtilities.isEveryFlagDisabled(this.syntaxTree, LCMasks.ASSIGN_MASK, LCMasks.RETURN_MASK, LCMasks.COND_MASK)
        && (this.functionScopeCount == 0)) {
      this.syntaxTree.addChild(fnCallNode);
    }

    this.syntaxTree.turnOffFlags(LCMasks.FUNCTION_CALL_MASK);

  }

  /**
   * Return statement enter context.
   */
  @Override
  public void enterReturnStatement(LittleCParser.ReturnStatementContext ctx) {
    this.syntaxTree.setFlags(LCMasks.RETURN_MASK);
  }

  /**
   * Return statement exit context. We do the type checking and check the flags
   * set by the function declaration listener listener.
   */
  @Override
  public void exitReturnStatement(LittleCParser.ReturnStatementContext ctx) {
    if (LCErrorListener.sawError()) {
      return;
    }
    LCSyntaxTree retExpr = this.values.get(ctx.expr());
    String fnRetType = this.functionReturnType;

    // If we have an expression, then we need to check the types. If they match, we
    // create the correct node and send its on its way. Otherwise, we print a type
    // mismatch error. If we're in a void fn, we print the appropriate error.
    if (ctx.expr() != null) {
      if (!retExpr.getType().equals(fnRetType)) {
        if (!fnRetType.equals("void")) {
          LCErrorListener.syntaxError(ctx,
              "function expects return type of " + fnRetType + " but got " + retExpr.getType() + ".");
          return;
        } else {
          LCErrorListener.syntaxError(ctx, "cannot return value in void function.");
          return;
        }
      }
    }
    // If the expression is null, then we should be in a void method. If not, we
    // throw an error.
    else {
      if (!fnRetType.equals("void")) {
        LCErrorListener.syntaxError(ctx, "cannot have a blank return expression in non-void function.");
        return;
      }
    }

    LCReturnStatementNode returnNode = new LCReturnStatementNode(ctx, retExpr);
    this.values.put(ctx, returnNode);
    this.syntaxTree.addChild(returnNode);
    this.syntaxTree.turnOffFlags(LCMasks.RETURN_MASK);
  }

  /**
   * Assignment statement node enter context; we set the flag to tell other nested
   * statements that we don't want to add this twice (to things like for loops,
   * returns, etc.).
   */
  @Override
  public void enterAssignStatement(LittleCParser.AssignStatementContext ctx) {
    this.syntaxTree.setFlags(LCMasks.ASSIGN_MASK);
    this.assignScopeCount++;
  }

  /**
   * Assignment statement exit context listener. All type-checking is handled
   * inside the node itself, but id existence is verified here.
   */
  @Override
  public void exitAssignStatement(LittleCParser.AssignStatementContext ctx) {
    if (LCErrorListener.sawError()) {
      return;
    }

    String id = ctx.ID().getText();
    LCSyntaxTree rvalue = null;
    LCSyntaxTree assignNode = null;

    // Fortunately, there are only five possibilities of how to assign something to
    // a node and they're all previously declared things in the map!
    if (!this.symbolTable.hasSymbol(id)) {
      LCErrorListener.syntaxError(ctx, "variable " + id + " is not previously declared.");
      return;
    }

    String lvalueType = this.symbolTable.getSymbolEntry(id).getVarType();

    // If there are two expressions, this means an array was created (or we tried to
    // use a non-array as an array). The second expression is the one we want to
    // assign.
    if (ctx.expr().size() == 2) {
      // If we dereference the array, then it has a "pseudotype" of whatever type of
      // array it is. This suggests that we can't do something like int x[5]; x = 5;
      // But we can do x[0] = 5;
      if (!LCUtilities.isTypeArray(this.symbolTable.getSymbolEntry(id).getVarType())) {
        LCErrorListener.syntaxError(ctx, "cannot treat non-array " + id + " as array.");
        return;
      }

      // When we're in here, this means that we HAVE to use an array; that's our
      // invariant.
      String arrType = LCUtilities.getArrayType(lvalueType);

      // We're assigning either a term or an expression.
      if (ctx.expr() != null) {
        rvalue = this.values.get(ctx.expr(1));
      } else if (ctx.term() != null) {
        rvalue = this.values.get(ctx.term());
      }

      // We need to create the array identifier, reference, and then the assignment
      // node.
      LCVariableIdentifierNode arrayIdentifier = new LCVariableIdentifierNode(ctx, symbolTable, id, lvalueType);
      LCArrayIndexNode arrayReference = new LCArrayIndexNode(ctx, arrType, arrayIdentifier,
          this.values.get(ctx.expr(0)));
      assignNode = new LCAssignmentNode(ctx, this.symbolTable, id, lvalueType, arrayReference, rvalue);
    } else {
      // If we're not using an array, we're either using a term
      // or another expression in the assignment.
      if (ctx.expr(0) != null) {
        rvalue = this.values.get(ctx.expr(0));
      } else if (ctx.term() != null) {
        rvalue = this.values.get(ctx.term());
      }

      assignNode = new LCAssignmentNode(ctx, this.symbolTable, id, lvalueType, rvalue);
    }

    // If we're not inside a conditional or nested expression, then
    // we can add this to the tree.
    if (LCUtilities.isEveryFlagDisabled(this.syntaxTree, LCMasks.EXPR_ASSIGN_MASK, LCMasks.COND_MASK)
        && this.assignScopeCount == 1) {
      this.syntaxTree.addChild(assignNode);
    }

    this.assignScopeCount--;
    this.values.put(ctx, assignNode);
    this.syntaxTree.turnOffFlags(LCMasks.ASSIGN_MASK);
  }

// ======================== END STATEMENTS ===============================//

// ======================== EXPRESSIONS ===============================//

  /**
   * Term inside expression enter context.
   */
  @Override
  public void enterExprTerm(LittleCParser.ExprTermContext ctx) {
    // We either have an ID or a literal. We first check for an ID.
    if (ctx.term().ID() != null) {
      String id = ctx.term().ID().getText();
      if (this.symbolTable.hasSymbol(id)) {
        String varType = this.symbolTable.getSymbolEntry(id).getVarType();
        LCVariableIdentifierNode varIdentifier = new LCVariableIdentifierNode(ctx, symbolTable, id, varType);
        this.values.put(ctx, varIdentifier);
      } else {
        LCErrorListener.syntaxError(ctx, "variable " + id + " was not previously declared.");
        return;
      }
    }
    // Check for the existence of a literal.
    else {
      LCConstantLiteralNode constantLiteral = null;
      TerminalNode literalNode = (TerminalNode) ctx.term().getChild(0);
      int literalType = literalNode.getSymbol().getType();
      if (literalType == LittleCLexer.INTLIT) {
        String intLit = "";
        if (LCUtilities.isValidIntLiteral(literalNode.getText())) {
          intLit = "" + LCUtilities.getDecodedIntLiteral(literalNode.getText());
        } else {
          LCErrorListener.syntaxError(ctx, "cannot create an int literal.");
          return;
        }
        constantLiteral = new LCConstantLiteralNode(ctx, intLit, "int");
      } else if (literalType == LittleCLexer.CHARLIT) {
        String literalValue = String.valueOf((int) LCUtilities.getCharFromString(literalNode.getText()));
        constantLiteral = new LCConstantLiteralNode(ctx, literalValue, "char");
      } else if (literalType == LittleCLexer.STRINGLIT) {
        constantLiteral = new LCConstantLiteralNode(ctx, literalNode.getText(), "char[]");
      }

      this.values.put(ctx, constantLiteral);
    }
  }

  /**
   * Calling a function inside an expression exit context.
   */
  @Override
  public void exitExprFunctionCall(LittleCParser.ExprFunctionCallContext ctx) {
    if (this.values.get(ctx.ruleFunctionCall()) != null) {
      this.values.put(ctx, this.values.get(ctx.ruleFunctionCall()));
    } else {
      LCErrorListener.syntaxError(ctx, "cannot save parameters, did you call the function incorrectly?");
      return;
    }
  }

  /**
   * Expression pre operator exit context listener.
   */
  @Override
  public void exitExprPreOp(LittleCParser.ExprPreOpContext ctx) {
    // First check if the symbol exists.
    String id = ctx.ID().getText();
    String idType = this.symbolTable.getSymbolEntry(id).getVarType();
    String op = "";
    if (!this.symbolTable.hasSymbol(id)) {
      LCErrorListener.syntaxError(ctx, "variable " + id + " was not previously declared.");
      return;
    }

    // Find the pre operator symbol that we're using.
    if (ctx.INC_OP() != null) {
      op = "PRE-INC";
    } else if (ctx.DEC_OP() != null) {
      op = "PRE-DEC";
    } else {
      LCErrorListener.syntaxError(ctx, op + " is an invalid pre-expression operator.");
      return;
    }

    LCSyntaxTree lvar = new LCVariableIdentifierNode(ctx, this.symbolTable, id, idType);

    // If we have an expression that means we're using an array. Arrays are
    // l-values!
    if (ctx.expr() != null) {
      if (LCUtilities.isTypeArray(idType)) {
        idType = LCUtilities.getArrayType(idType);
        lvar = new LCArrayIndexNode(ctx, idType, lvar, this.values.get(ctx.expr()));
      }
    } else {
      // If the expression is null and we're on an array, that means we're
      // not using an AIDX node.
      if (lvar.isArray()) {
        LCErrorListener.syntaxError(ctx, "cannot use " + id + " as an array l-value for this prefix unary operator.");
        return;
      }
    }

    LCPrePostOperatorNode prePostOp = new LCPrePostOperatorNode(ctx, symbolTable, op, idType, lvar);

    // If we're not in a function and we're not in a assign statement,
    // then we can add the child. It's redundant otherwise.
    if (LCUtilities.isEveryFlagDisabled(this.syntaxTree, LCMasks.FUNCTION_CALL_MASK, LCMasks.ASSIGN_MASK,
        LCMasks.COND_MASK, LCMasks.RETURN_MASK)) {
      this.syntaxTree.addChild(prePostOp);
    }

    this.values.put(ctx, prePostOp);
  }

  /**
   * Expression post operator exit context listener. These are only used on
   * lvalues and cannot be used on literals or expressions that produce literals.
   */
  @Override
  public void exitExprPostOp(LittleCParser.ExprPostOpContext ctx) {
    if (LCErrorListener.sawError()) {
      return;
    }
    // First check if the symbol exists.
    String id = ctx.ID().getText();
    String idType = this.symbolTable.getSymbolEntry(id).getVarType();
    String op = "";

    if (!this.symbolTable.hasSymbol(id)) {
      LCErrorListener.syntaxError(ctx, "variable " + id + " was not previously declared.");
      return;
    }

    // Find the post operator symbol that we're using.
    if (ctx.INC_OP() != null) {
      op = "POST-INC";
    } else if (ctx.DEC_OP() != null) {
      op = "POST-DEC";
    } else {
      LCErrorListener.syntaxError(ctx, op + " is an invalid post-expression operator.");
      return;
    }

    LCSyntaxTree lvar = new LCVariableIdentifierNode(ctx, this.symbolTable, id, idType);

    // If we have an expression that means we're using an array. Arrays are
    // l-values!
    if (ctx.expr() != null) {
      if (LCUtilities.isTypeArray(idType)) {
        idType = LCUtilities.getArrayType(idType);
        lvar = new LCArrayIndexNode(ctx, idType, lvar, this.values.get(ctx.expr()));
      }
    } else {
      // If the expression is null and we're on an array, that means we're
      // not using an AIDX node.
      if (lvar.isArray()) {
        LCErrorListener.syntaxError(ctx, "cannot use " + id + " as an array l-value for this postfix unary operator.");
        return;
      }
    }

    LCPrePostOperatorNode prePostOp = new LCPrePostOperatorNode(ctx, symbolTable, op, idType, lvar);

    // If we're not in a function and we're not in a assign statement,
    // then we can add the child. It's redundant otherwise.
    if (LCUtilities.isEveryFlagDisabled(this.syntaxTree, LCMasks.FUNCTION_CALL_MASK, LCMasks.ASSIGN_MASK,
        LCMasks.COND_MASK, LCMasks.RETURN_MASK)) {
      this.syntaxTree.addChild(prePostOp);
    }

    this.values.put(ctx, prePostOp);
  }

  /**
   * Expression unary operator exit context. Unary operators are only present in
   * expressions so we're good. Checks are done to make sure that appropriate
   * operators are used (for instance, the size operator is only used on arrays).
   */
  @Override
  public void exitExprUnary(LittleCParser.ExprUnaryContext ctx) {
    LCSyntaxTree rexpr = this.values.get(ctx.expr());
    int tokenOp = ((TerminalNode) ctx.getChild(0)).getSymbol().getType();
    String op = ((TerminalNode) ctx.getChild(0)).getSymbol().getText();
    String varType = rexpr.getType();

    // Check the expression type and make sure we're using the right op on the right
    // r-value.
    if (rexpr.isArray()) {
      if (tokenOp != LittleCLexer.SIZE_OP) {
        LCErrorListener.syntaxError(ctx, "invalid unary operator for r-value expression of type " + varType + ".");
      } else {
        varType = "int";
      }
    } else if (tokenOp == LittleCLexer.SIZE_OP) {
      LCErrorListener.syntaxError(ctx, "invalid unary operator for r-value expression of type " + varType + ".");
    }

    LCUnaryOperatorNode unaryOpNode = new LCUnaryOperatorNode(ctx, this.symbolTable, op, varType, rexpr);
    this.values.put(ctx, unaryOpNode);
  }

  /**
   * Binary operator in expression exit context listener. All operators correspond
   * to an appropriate lvalue and rvalue, meaning that they can only be used with
   * a specific data type. For the most part (in fact, for all parts), these are
   * ints.
   */
  @Override
  public void exitExprBinaryOp(LittleCParser.ExprBinaryOpContext ctx) {
    if (LCErrorListener.sawError()) {
      return;
    }
    LCSyntaxTree lexpr = this.values.get(ctx.expr().get(0));
    LCSyntaxTree rexpr = this.values.get(ctx.expr().get(1));
    ParseTree opNode = ctx.getChild(1);

    if (opNode != null) {
      boolean lStr = lexpr.isArray();
      boolean rStr = rexpr.isArray();
      if (lStr || rStr) {
        LCErrorListener.syntaxError(ctx, "cannot use binary operator on array datatype.");
        return;
      }
    }

    LCBinaryOperatorNode binaryOpNode = new LCBinaryOperatorNode(ctx, this.symbolTable, opNode.getText(), lexpr, rexpr);
    this.values.put(ctx, binaryOpNode);
  }

  /**
   * Term enter context listener. A term is defined as a literal or an identifier
   * in an expression.
   */
  @Override
  public void enterTerm(LittleCParser.TermContext ctx) {
  }

  /**
   * Term exit context listener. A term is defined as a literal or an identifier
   * in an expression.
   */
  @Override
  public void exitTerm(LittleCParser.TermContext ctx) {
    // We either have an ID or a literal. We first check for an ID.
    if (ctx.ID() != null) {
      String id = ctx.ID().getText();
      if (this.symbolTable.hasSymbol(id)) {
        String varType = this.symbolTable.getSymbolEntry(id).getVarType();
        LCVariableIdentifierNode varIdentifier = new LCVariableIdentifierNode(ctx, symbolTable, ctx.ID().getText(),
            varType);
        this.values.put(ctx, varIdentifier);
      } else {
        LCErrorListener.syntaxError(ctx, "variable " + id + " was not previously declared.");
        return;
      }
    }
    // Here we check for the existence of a literal.
    else {
      LCConstantLiteralNode constantLiteral = null;
      if (ctx.INTLIT() != null) {
        String intLit = "";
        if (LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
          intLit = "" + LCUtilities.getDecodedIntLiteral(ctx.INTLIT().getText());
        } else {
          LCErrorListener.syntaxError(ctx, "cannot create an int literal.");
          return;
        }
        constantLiteral = new LCConstantLiteralNode(ctx, intLit, "int");
      } else if (ctx.CHARLIT() != null) {
        String characterStr = ctx.CHARLIT().getText();
        String literalValue = String.valueOf((int) LCUtilities.getCharFromString(characterStr));
        constantLiteral = new LCConstantLiteralNode(ctx, literalValue, "char");
      } else if (ctx.STRINGLIT() != null) {
        constantLiteral = new LCConstantLiteralNode(ctx, ctx.STRINGLIT().getText(), "char[]");
      }
      this.values.put(ctx, constantLiteral);
    }
  }

  /**
   * Expression parenthesis exit listener "(" <expr> ")".
   */
  public void exitExprParen(LittleCParser.ExprParenContext ctx) {
    this.values.put(ctx, this.values.get(ctx.expr()));
  }

  /**
   * Expression array reference exit listener (using an array in an expression).
   * For instance, foo = a[i] + bar;
   * 
   * The exit listener gets the array type (int[], char[]), the backing element
   * type (int, char), and creates the indexing node.
   */
  @Override
  public void exitExprArray(LittleCParser.ExprArrayContext ctx) {
    if (LCErrorListener.sawError()) {
      return;
    }

    String id = ctx.ID().getText();
    if (!this.symbolTable.hasSymbol(id)) {
      LCErrorListener.syntaxError(ctx, "array object was not previously declared.");
      return;
    }

    // Gets the array type and then extracts the type of array.
    String arrayType = this.symbolTable.getSymbolEntry(id).getVarType();
    String elementType = LCUtilities.getArrayType(arrayType);

    // Create the nodes for the identifier, the index expression, and the node
    // itself. Note that the array identifier is ONLY FOR SHOW.
    LCSyntaxTree arrayIdentifier = new LCVariableIdentifierNode(ctx, symbolTable, id, arrayType);
    LCSyntaxTree indexExpr = this.values.get(ctx.expr());

    LCArrayIndexNode arrayIndexNode = new LCArrayIndexNode(ctx, elementType, arrayIdentifier, indexExpr);

    this.values.put(ctx, arrayIndexNode);
  }

  /**
   * Enter expression assignment (e.g. a = a + (b = c);)
   */
  @Override
  public void enterExprAssign(LittleCParser.ExprAssignContext ctx) {
    this.syntaxTree.setFlags(LCMasks.EXPR_ASSIGN_MASK);
  }

  /**
   * Exiting expression assignment.
   */
  @Override
  public void exitExprAssign(LittleCParser.ExprAssignContext ctx) {
    this.values.put(ctx, this.values.get(ctx.ruleAssignStatement()));
    this.syntaxTree.turnOffFlags(LCMasks.EXPR_ASSIGN_MASK);
  }

// ======================== END EXPRESSIONS ===============================//

// ======================== DECLARATIONS ===============================//

  /**
   * Exit declaration for an integer variable.
   */
  @Override
  public void exitIntDeclaration(LittleCParser.IntDeclarationContext ctx) {
    String lValue = ctx.ID().getText();
    String storageClass = LCUtilities.getStorageClassType(ctx.optStorageClass());
    Object literalValue = null;

    // If we're assigning to something, grab the literal value.
    if (ctx.INTLIT() != null) {
      if (LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
        literalValue = LCUtilities.getDecodedIntLiteral(ctx.INTLIT().getText());
      } else {
        LCErrorListener.syntaxError(ctx, "cannot create an int literal.");
        return;
      }
    } else if (ctx.CHARLIT() != null) {
      literalValue = (int) LCUtilities.getCharFromString(ctx.CHARLIT().getText());
    } else {
      LCErrorListener.syntaxWarning(ctx, "int " + lValue + " may not have been initialized.");
    }

    LCVariableDeclarationNode intDeclarationNode = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, "int",
        storageClass, literalValue);

    this.syntaxTree.addChild(intDeclarationNode);
    this.values.put(ctx, intDeclarationNode);
  }

  /**
   * Enter declaration for an integer array context.
   */
  @Override
  public void exitIntArrayDeclaration(LittleCParser.IntArrayDeclarationContext ctx) {
    String lValue = ctx.ID().getText();
    String type = "int[" + ctx.INTLIT().getText() + "]";
    String storageClass = LCUtilities.getStorageClassType(ctx.optStorageClass());
    Object literalValue = null;

    // We need to test to see if the size is valid or not. It doesn't matter where
    // we store it; it just needs to be valid.
    if (!LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
      LCErrorListener.syntaxError(ctx, "cannot create an int literal for array index.");
      return;
    }

    LCVariableDeclarationNode intArrayDeclaration = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, type,
        storageClass, literalValue);

    this.syntaxTree.addChild(intArrayDeclaration);
    this.values.put(ctx, intArrayDeclaration);
  }

  /**
   * Exit int array reference declaration context.
   */
  @Override
  public void exitIntArrayRefDeclaration(LittleCParser.IntArrayRefDeclarationContext ctx) {
    String lValue = ctx.ID().getText();
    String type = "int[]";
    String storageClass = LCUtilities.getStorageClassType(ctx.optStorageClass());
    Object literalValue = null;

    LCVariableDeclarationNode intArrayRef = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, type,
        storageClass, literalValue);

    this.syntaxTree.addChild(intArrayRef);
    this.values.put(ctx, intArrayRef);
  }

  /**
   * Exit declaration for a char variable.
   */
  @Override
  public void exitCharDeclaration(LittleCParser.CharDeclarationContext ctx) {
    String lValue = ctx.ID().getText();
    String storageClass = LCUtilities.getStorageClassType(ctx.optStorageClass());
    Object literalValue = null;

    // If we're assigning to something, grab the literal value.
    if (ctx.CHARLIT() != null) {
      literalValue = (int) LCUtilities.getCharFromString(ctx.CHARLIT().getText());
    } else if (ctx.INTLIT() != null) {
      if (LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
        literalValue = LCUtilities.getDecodedIntLiteral(ctx.INTLIT().getText());
      } else {
        LCErrorListener.syntaxError(ctx, "cannot create an int literal.");
        return;
      }
    } else {
      LCErrorListener.syntaxWarning(ctx, "char " + lValue + " may not have been initialized.");
    }

    LCVariableDeclarationNode charDeclarationNode = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, "char",
        storageClass, literalValue);

    this.syntaxTree.addChild(charDeclarationNode);
    this.values.put(ctx, charDeclarationNode);
  }

  /**
   * Exit declaration for a string literal (char array).
   */
  @Override
  public void exitStringDeclaration(LittleCParser.StringDeclarationContext ctx) {
    String lValue = ctx.ID().getText();
    String type = "char[" + ctx.INTLIT().getText() + "]";
    String storageClass = LCUtilities.getStorageClassType(ctx.optStorageClass());
    Object literalValue = null;

    // If we're assigning to something, grab the literal value.
    if (ctx.STRINGLIT() != null) {
      literalValue = ctx.STRINGLIT().getText();
    }

    // We need to test to see if the size is valid or not. It doesn't matter where
    // we store it; it just needs to be valid.
    if (!LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
      LCErrorListener.syntaxError(ctx, "cannot create an int literal for array index.");
      return;
    }

    LCVariableDeclarationNode stringDeclarationNode = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, type,
        storageClass, literalValue);

    this.syntaxTree.addChild(stringDeclarationNode);
    this.values.put(ctx, stringDeclarationNode);
  }

  /**
   * Exit string (char[]) reference declaration context).
   */
  @Override
  public void exitStringRefDeclaration(LittleCParser.StringRefDeclarationContext ctx) {
    String lValue = ctx.ID().getText();
    String type = "char[]";
    String storageClass = LCUtilities.getStorageClassType(ctx.optStorageClass());
    Object literalValue = null;

    LCVariableDeclarationNode stringRef = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, type,
        storageClass, literalValue);

    this.syntaxTree.addChild(stringRef);
    this.values.put(ctx, stringRef);
  }

  // ======================== END DECLARATIONS ===============================//

  /**
   * Returns a syntax tree after successful parsing.
   *
   * @return a syntax tree, or null if an error was detected.
   */
  public LCSyntaxTree getSyntaxTree() {
//    if (LCErrorListener.sawWarning()) {
//      LCErrorListener.printWarnings();
//    }

    if (LCErrorListener.sawError()) {
      LCErrorListener.printErrors();
      return null;
    }

    return this.syntaxTree;
  }

  /**
   * Returns the symbol table. Can be called at any time, but generally this will
   * be called after all parsing is complete to get the final symbol table
   * containing all global declarations.
   *
   * @return the symbol table
   */
  public SymbolTable getSymbolTable() {
    return this.symbolTable;
  }

  /**
   * Adds the default functions from LittleC to the global functions symbol table.
   */
  private void addDefaultGlobalFunctions() {
    /* Adds the prints function. */
    LinkedList<LCSyntaxTree> args = new LinkedList<>();
    args.add(new LCVariableIdentifierNode(null, symbolTable, "str", "char[]"));
    this.symbolTable.addSymbol("prints", new SymbolEntry("FNDEF", "void", "extern", args));
    args = new LinkedList<>();

    /* Adds the printd function. */
    args.add(new LCVariableIdentifierNode(null, symbolTable, "number", "int"));
    this.symbolTable.addSymbol("printd", new SymbolEntry("FNDEF", "void", "extern", args));
    args = new LinkedList<>();

    /* Adds the printc function. */
    args.add(new LCVariableIdentifierNode(null, symbolTable, "number", "char"));
    this.symbolTable.addSymbol("printc", new SymbolEntry("FNDEF", "void", "extern", args));
    args = new LinkedList<>();

    /* Adds the printf function. */
    args.add(new LCVariableIdentifierNode(null, symbolTable, "number", "float"));
    this.symbolTable.addSymbol("printf", new SymbolEntry("FNDEF", "void", "extern", args));
    args = new LinkedList<>();

    /* Adds the read() function. */
    this.symbolTable.addSymbol("read", new SymbolEntry("FNDEF", "int", "extern", args));
    args = new LinkedList<>();

    /* Adds the readc() function. */
    this.symbolTable.addSymbol("readc", new SymbolEntry("FNDEF", "char", "extern", args));
    args = new LinkedList<>();

    /* Adds the readf() function. */
    this.symbolTable.addSymbol("readf", new SymbolEntry("FNDEF", "float", "extern", args));
    args = new LinkedList<>();

    /* Add the readline() function. */
    args.add(new LCVariableIdentifierNode(null, symbolTable, "str", "char[]"));
    this.symbolTable.addSymbol("readline", new SymbolEntry("FNDEF", "void", "extern", args));
  }
}
//Why is Dr. Tate so evilllllllllllllllllllllllll
