package edu.joshuacrotts.littlec.main;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

import org.antlr.v4.runtime.tree.ParseTreeProperty;

import edu.joshuacrotts.littlec.antlr4.LittleCBaseListener;
import edu.joshuacrotts.littlec.antlr4.LittleCParser;
import edu.joshuacrotts.littlec.antlr4.LittleCParser.ExprContext;
import edu.joshuacrotts.littlec.antlr4.LittleCParser.RuleFunctionDeclarationParametersContext;
import edu.joshuacrotts.littlec.syntaxtree.LCArrayIndexNode;
import edu.joshuacrotts.littlec.syntaxtree.LCAssignmentNode;
import edu.joshuacrotts.littlec.syntaxtree.LCBinaryOperatorNode;
import edu.joshuacrotts.littlec.syntaxtree.LCBreakStatementNode;
import edu.joshuacrotts.littlec.syntaxtree.LCConstantLiteralNode;
import edu.joshuacrotts.littlec.syntaxtree.LCFunctionArgsListNode;
import edu.joshuacrotts.littlec.syntaxtree.LCFunctionCallNode;
import edu.joshuacrotts.littlec.syntaxtree.LCFunctionDefinitionNode;
import edu.joshuacrotts.littlec.syntaxtree.LCFunctionPrototypeNode;
import edu.joshuacrotts.littlec.syntaxtree.LCIfStatementNode;
import edu.joshuacrotts.littlec.syntaxtree.LCLoopStatementNode;
import edu.joshuacrotts.littlec.syntaxtree.LCPrePostOperatorNode;
import edu.joshuacrotts.littlec.syntaxtree.LCReturnStatementNode;
import edu.joshuacrotts.littlec.syntaxtree.LCSyntaxTree;
import edu.joshuacrotts.littlec.syntaxtree.LCUnaryOperatorNode;
import edu.joshuacrotts.littlec.syntaxtree.LCVariableDeclarationNode;
import edu.joshuacrotts.littlec.syntaxtree.LCVariableIdentifierNode;

/**
 * This class will contain all of your listener methods, which are called every
 * time a rule is entered or exited during parsing. This is what ties your
 * LittleC.g4 grammar file to your syntax tree creation methods.
 *
 * You can decide what listeners you need, and how to structure your code, but
 * you must provide the methods shown below.
 */
public class LCListener extends LittleCBaseListener {

  /** 
   * Map for storing nodes for later lookup. 
   */
  private final ParseTreeProperty<LCSyntaxTree> values;

  /** 
   * Default LittleCParser object generated by ANTLR. 
   */
  private LittleCParser parser;

  /** 
   * Symbol table for the IDs and types of all variables and functions. 
   */
  private SymbolTable symbolTable;

  /** 
   * Syntax tree generated for traversal. 
   */
  private LCSyntaxTree syntaxTree;

  /**
   * Way to keep track of the current syntax tree to append nodes to if we go into
   * a different scope. This is useful for when we reassign the scope for a
   * function, if statement, while or for loop.
   */
  private Stack<LCSyntaxTree> syntaxTreeScopes;

  /** 
   * Keeps track of the current number of nested functions we have. 
   */
  private int functionScopeCount = 0;

  /** 
   * Keeps track of nested for/while loop scopes. 
   */
  private int loopScopeCount = 0;

  /** 
   * Keeps track of how many nested assignment expressions we have. 
   */
  private int assignScopeCount = 0;

  /**
   * This constructor is expected by ParserTest, and so needs to be defined.
   * Initializes the syntax tree node, the scopes stack, and the symbol table.
   * 
   * @param parser - the parser class generated from ANTLR.
   */
  public LCListener(LittleCParser parser) {
    this.parser = parser;
    this.syntaxTree = new LCSyntaxTree();
    this.syntaxTreeScopes = new Stack<>();
    this.symbolTable = new SymbolTable();
    this.symbolTable.addEnvironment();
    this.values = new ParseTreeProperty<>();
    this.addDefaultGlobalFunctions();
  }

// ======================== STATEMENTS ===============================//

  /**
   * Enter program context listener.
   */
  @Override
  public void enterProgram(LittleCParser.ProgramContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Exit program context listener.
   */
  @Override
  public void exitProgram(LittleCParser.ProgramContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Enter statement context listener.
   */
  @Override
  public void enterStmt(LittleCParser.StmtContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Exit statement context listener.
   */
  @Override
  public void exitStmt(LittleCParser.StmtContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Enter new block scope. A new block is defined by a set of opening and closing
   * braces. It's akin to a mini program within the program.
   */
  @Override
  public void enterNewBlock(LittleCParser.NewBlockContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    /*
     * We need to create a new LCSyntaxTree to add to the fnDefNode so it makes a
     * new scope.
     */
    LCSyntaxTree newScope = new LCSyntaxTree();

    this.syntaxTree.addChild(newScope);

    /*
     * We push the current syntaxtree for traversal to the stack so we can save its
     * context.
     */
    this.syntaxTreeScopes.push(this.syntaxTree);

    /*
     * Set the scope of the syntax tree to be this new one so variables can easily
     * add to it.
     */
    this.syntaxTree = newScope;
    this.symbolTable.addEnvironment();
  }

  /**
   * Exiting a new block scope. Similar to leaving an if/while/for loop context.
   */
  public void exitNewBlock(LittleCParser.NewBlockContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    /*
     * Removes the current environment from the stack and the syntax tree scope is
     * appended back to the main tree.
     */
    this.symbolTable.popEnvironment();
    this.syntaxTree = this.syntaxTreeScopes.pop();
  }

  /**
   * Enter if statement context listener.
   */
  @Override
  public void enterIfStatement(LittleCParser.IfStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // If we are using a multi-line if statement, we create a new syntax tree, push
    // the old one to the stack and build subsequent nodes to this if statement
    // node.
    if (ctx.OPEN_BRACE() != null && ctx.CLOSE_BRACE() != null) {
      this.syntaxTree.setFlags(LCMasks.MULTI_LINE_MASK);
    }

    this.syntaxTree.setFlags(LCMasks.IF_MASK);
  }

  /**
   * Exit if statement context listener.
   */
  @Override
  public void exitIfStatement(LittleCParser.IfStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    LCSyntaxTree condPortion = null;
    LCSyntaxTree thenPortion = null;
    LCSyntaxTree elsePortion = this.values.get(ctx.ruleElseStatement());

    if (ctx.OPEN_BRACE() != null && ctx.CLOSE_BRACE() != null) {
      // First, we grab the saved expression. 
      condPortion = this.values.get(ctx.ruleIfStatementCond());
      // Then, we get the children of the if statement node (the THEN part).
      List<LCSyntaxTree> thenPortionChildren = this.syntaxTree.getChildren();
      thenPortion = new LCSyntaxTree();

      // Add each child of the "then" tree to a new node that gets added as a SEQ call.
      for (LCSyntaxTree t : thenPortionChildren) {
        thenPortion.addChild(t);
      }

      // Reset the current syntax tree.
      this.syntaxTree = this.syntaxTreeScopes.pop();
    } else {
      // The last-added child is whatever comes directly after the conditional part so
      // we can just remove it from the main tree and add it to the cond tree if it's
      // a one-line if statement (i.e. no braces are used).
      thenPortion = this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);
      condPortion = this.values.get(ctx.ruleIfStatementCond());
    }

    this.syntaxTree.addChild(new LCIfStatementNode(ctx, condPortion, thenPortion, elsePortion));
    this.syntaxTree.turnOffFlags(LCMasks.IF_MASK);
  }

  /**
   * Enter if statement conditional context. This is unused.
   */
  @Override
  public void enterIfStatementConditional(LittleCParser.IfStatementConditionalContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    this.syntaxTree.setFlags(LCMasks.COND_MASK);
  }

  /**
   * Exit if statement conditional context. Since expressions and function calls
   * can be used in an if statement conditional, we need to determine when we
   * enter/exit one.
   */
  @Override
  public void exitIfStatementConditional(LittleCParser.IfStatementConditionalContext ctx) {
    if ((this.syntaxTree.getFlags() & LCMasks.MULTI_LINE_MASK) != 0) {
      LCSyntaxTree ifStatement = new LCSyntaxTree();
      this.syntaxTreeScopes.push(this.syntaxTree);
      this.syntaxTree = ifStatement;
    }

    if (ctx.expr() != null) {
      this.values.put(ctx, this.values.get(ctx.expr()));
    } else {
      this.values.put(ctx, this.values.get(ctx.ruleAssignStatement()));
    }

    this.syntaxTree.turnOffFlags(LCMasks.COND_MASK);
    this.syntaxTree.turnOffFlags(LCMasks.MULTI_LINE_MASK);
  }

  /**
   * Enter else statement listener. If we are using a multi-line else statement
   * (i.e. braces are used), then we create a new syntaxtree and save the old one
   * so we can come back to it.
   */
  @Override
  public void enterElseStatement(LittleCParser.ElseStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // If we have a multi-line else statement (with braces), we have to add a new
    // sequence context.
    if (ctx.OPEN_BRACE() != null && ctx.CLOSE_BRACE() != null) {
      LCSyntaxTree elseStatement = new LCSyntaxTree();
      this.syntaxTreeScopes.push(this.syntaxTree);
      this.syntaxTree = elseStatement;
    }
  }

  /**
   * Exit else statement context listener. Else statements are optional.
   */
  @Override
  public void exitElseStatement(LittleCParser.ElseStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.OPEN_BRACE() != null && ctx.CLOSE_BRACE() != null) {
      // We get the children of the else statement node.
      List<LCSyntaxTree> elsePortionChildren = this.syntaxTree.getChildren();
      LCSyntaxTree elsePortion = new LCSyntaxTree();

      // Add each child of the else tree to a new node that gets appended to the if
      // node later on.
      for (LCSyntaxTree t : elsePortionChildren) {
        elsePortion.addChild(t);
      }

      this.values.put(ctx, elsePortion);

      // Reset the current syntax tree.
      this.syntaxTree = this.syntaxTreeScopes.pop();
    } else {
      // If this is a one-line if statement, just get the last added node and save it
      // since that's the one we have to use.
      LCSyntaxTree lastChild = this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);
      this.values.put(ctx, lastChild);
    }
  }

  /**
   * Enter while statement context listener. A new syntax tree scope is pushed to
   * store all newly-created nodes in this new block.
   */
  @Override
  public void enterWhileStatement(LittleCParser.WhileStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // If there are braces for the while statement then we push a new sequence
    // context.
    if (ctx.OPEN_BRACE() != null && ctx.CLOSE_BRACE() != null) {
      this.syntaxTree.setFlags(LCMasks.MULTI_LINE_MASK);
    }

    this.syntaxTree.setFlags(LCMasks.LOOP_MASK);
    this.loopScopeCount++;
  }

  /**
   * Exit while statement context listener. This is replicated for the for loop
   * minus a few pieces.
   */
  @Override
  public void exitWhileStatement(LittleCParser.WhileStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    LCSyntaxTree condPortion = null;
    LCSyntaxTree loopBody = null;

    if (ctx.OPEN_BRACE() != null && ctx.CLOSE_BRACE() != null) {
      // First, we grab the saved expression.
      condPortion = this.values.get(ctx.ruleWhileStatementCond());

      // Then, we get the children of the while statement node (the BODY part).
      List<LCSyntaxTree> bodyPortionChildren = this.syntaxTree.getChildren();
      loopBody = new LCSyntaxTree();

      // Add each child of the "body" tree to a new node that gets added as a SEQ
      // call.
      for (LCSyntaxTree b : bodyPortionChildren) {
        loopBody.addChild(b);
      }

      // Reset the current syntax tree.
      this.syntaxTree = this.syntaxTreeScopes.pop();
    } else {
      // The last-added child is whatever comes directly after the while cond part so
      // we can just remove it from the main tree and add it to the cond tree.
      loopBody = this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);
      condPortion = this.values.get(ctx.ruleWhileStatementCond());
    }

    this.syntaxTree.addChild(new LCLoopStatementNode(ctx, condPortion, loopBody));

    // Turn off the flag for being in a loop.
    this.syntaxTree.turnOffFlags(LCMasks.LOOP_MASK);
    this.loopScopeCount--;
  }

  /**
   * Enter while statement conditional context. This is unused.
   */
  @Override
  public void enterWhileStatementConditional(LittleCParser.WhileStatementConditionalContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    this.syntaxTree.setFlags(LCMasks.COND_MASK);
  }

  /**
   * Exit while statement conditional context. If there are multiple lines to this
   * while loop, we set the flags and push a new ST.
   */
  @Override
  public void exitWhileStatementConditional(LittleCParser.WhileStatementConditionalContext ctx) {
    if ((this.syntaxTree.getFlags() & LCMasks.MULTI_LINE_MASK) != 0) {
      LCSyntaxTree whileStatement = new LCSyntaxTree();
      this.syntaxTreeScopes.push(this.syntaxTree);
      this.syntaxTree = whileStatement;
    }

    if (ctx.expr() != null) {
      this.values.put(ctx, this.values.get(ctx.expr()));
    } else {
      this.values.put(ctx, this.values.get(ctx.ruleAssignStatement()));
    }

    this.syntaxTree.turnOffFlags(LCMasks.COND_MASK);
    this.syntaxTree.turnOffFlags(LCMasks.MULTI_LINE_MASK);
  }

  /**
   * Enter for statement context listener. A new syntax tree scope is pushed to
   * store all newly-created nodes in this new block.
   */
  @Override
  public void enterForStatement(LittleCParser.ForStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.OPEN_BRACE() != null && ctx.CLOSE_BRACE() != null) {
      this.syntaxTree.setFlags(LCMasks.MULTI_LINE_MASK);
    }

    this.syntaxTree.setFlags(LCMasks.LOOP_MASK);
    this.loopScopeCount++;
  }

  /**
   * Exit for statement context listener. The differnet pieces of the for loop are
   * constructed here. Some pieces of the for loop are located in the current
   * syntax tree, so those are removed and re-stored in the for loop construction
   * node.
   */
  @Override
  public void exitForStatement(LittleCParser.ForStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    LCSyntaxTree loopInitializeExpression = null;
    LCSyntaxTree loopTestExpression = null;
    LCSyntaxTree loopUpdateExpression = null;
    LCSyntaxTree loopBody = null;
    LCSyntaxTree outerLoopBody = new LCSyntaxTree();

    if (ctx.OPEN_BRACE() != null && ctx.CLOSE_BRACE() != null) {
      // First, we grab the saved expression.
      loopInitializeExpression = this.values.get(ctx.ruleAssignStatement(0));

      // Now grab the conditional portion.
      loopTestExpression = this.values.get(ctx.ruleForStatementCond());

      // Finally, grab the update expression.
      // If ctx.expr() is null, then that means we have an assignment e.g. k = k + 1.
      // Otherwise, it's an expression i++ etc.
      loopUpdateExpression = (ctx.expr() == null) ? (this.values.get(ctx.ruleAssignStatement(1)))
          : (this.values.get(ctx.expr()));

      // Then, we get the children of the while statement node (the BODY part).
      List<LCSyntaxTree> bodyPortionChildren = this.syntaxTree.getChildren();

      // The first two children are just the assignment and condition so they are
      // omitted.
      bodyPortionChildren.remove(0);
      bodyPortionChildren.remove(0);
      loopBody = new LCSyntaxTree();

      for (LCSyntaxTree b : bodyPortionChildren) {
        loopBody.addChild(b);
      }

      // Reset the current syntax tree.
      this.syntaxTree = this.syntaxTreeScopes.pop();
    } else {
      // The last-added child is whatever comes directly after the while cond part so
      // we can just remove it from the main tree and add it to the cond tree.
      loopBody = this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);

      // First, we grab the saved expression.
      loopInitializeExpression = this.values.get(ctx.ruleAssignStatement(0));

      // Now grab the conditional portion.
      loopTestExpression = this.values.get(ctx.ruleForStatementCond());

      // Finally, grab the update expression.
      loopUpdateExpression = ctx.expr() == null ? this.values.get(ctx.ruleAssignStatement(1))
          : this.values.get(ctx.expr());

      // Similarly to the way we removed the first two children in the above
      // condition, the last two in this version (without braces) has the same issue.
      this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);
      this.syntaxTree.getChildren().remove(this.syntaxTree.getChildren().size() - 1);
    }
    
    // The outer body of the loop has the inner body as a seq and the update expr.
    outerLoopBody.addChild(loopBody);
    outerLoopBody.addChild(loopUpdateExpression);

    // Create a dummy tree to add our initialization expr to.
    LCSyntaxTree seqFor = new LCSyntaxTree();

    // Now add the sequence of for statements to the parent tree.
    seqFor.addChild(loopInitializeExpression);
    seqFor.addChild(new LCLoopStatementNode(ctx, loopTestExpression, outerLoopBody));

    // Now we append the corrected seqFor tree.
    this.syntaxTree.addChild(seqFor);

    // Turn off the flag for being in a loop.
    this.syntaxTree.turnOffFlags(LCMasks.LOOP_MASK);
    this.loopScopeCount--;
  }

  /**
   * Enter while statement conditional context. This is unused.
   */
  @Override
  public void enterForStatementConditional(LittleCParser.ForStatementConditionalContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    this.syntaxTree.setFlags(LCMasks.COND_MASK);
  }

  /**
   * For while statement conditional context. If there are multiple lines to this
   * while loop, we set the flags and push a new ST.
   */
  @Override
  public void exitForStatementConditional(LittleCParser.ForStatementConditionalContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if ((this.syntaxTree.getFlags() & LCMasks.MULTI_LINE_MASK) != 0) {
      LCSyntaxTree forBody = new LCSyntaxTree();
      this.syntaxTreeScopes.push(this.syntaxTree);
      this.syntaxTree = forBody;
    }

    if (ctx.expr() != null) {
      this.values.put(ctx, this.values.get(ctx.expr()));
    } else {
      this.values.put(ctx, this.values.get(ctx.ruleAssignStatement()));
    }

    this.syntaxTree.turnOffFlags(LCMasks.COND_MASK);
    this.syntaxTree.turnOffFlags(LCMasks.MULTI_LINE_MASK);
  }

  /**
   * Break statement enter context listener.
   */
  @Override
  public void enterBreakStatement(LittleCParser.BreakStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Break statement exit context listener. The verification for break statement
   * location is performed here.
   */
  @Override
  public void exitBreakStatement(LittleCParser.BreakStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    LCBreakStatementNode breakStmt = new LCBreakStatementNode(ctx);

    // We have to make sure that we're actually inside of a loop to break.
    if (this.loopScopeCount > 0) {
      this.syntaxTree.addChild(breakStmt);
      this.values.put(ctx, breakStmt);
    } else {
      this.syntaxTree.printError(ctx, "break statement cannot be used outside a loop.");
      this.syntaxTree.setFlags(LCMasks.ERROR_MASK);
      return;
    }
  }

  /**
   * Function prototype context enter listener.
   */
  @Override
  public void enterFunctionPrototype(LittleCParser.FunctionPrototypeContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Function prototype context exit listener. A function prototype is only added
   * to the symbol table in case a function uses it before the definition is
   * declared. This is just like a normal C function prototype.
   */
  @Override
  public void exitFunctionPrototype(LittleCParser.FunctionPrototypeContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.ID() != null) {
      String id = ctx.ID().getText();
      String storageClass = LCUtilities.getStorageClassType(ctx.EXTERN(), ctx.STATIC());
      String retType = null;

      if (ctx.INT() != null) {
        retType = "int";
        this.syntaxTree.setFlags(LCMasks.RETURN_INT_MASK);
      } else if (ctx.CHAR() != null) {
        retType = "char";
        this.syntaxTree.setFlags(LCMasks.RETURN_CHAR_MASK);
      } else if (ctx.VOID() != null) {
        retType = "void";
        this.syntaxTree.setFlags(LCMasks.RETURN_VOID_MASK);
      } else {
        this.syntaxTree.printError(ctx, "required return type is unspecified.");
        return;
      }

      // We pull in the ID and the datatype of the parameter in the prototype, and
      // store it in a HashMap.
      LinkedHashMap<String, String> args = new LinkedHashMap<String, String>();
      // Kind of a junky way of doing it but I'll keep it this way for now.
      RuleFunctionDeclarationParametersContext p = ctx.ruleFunctionDeclarationParameters(0);
      final int SPACE_PER_ARG = 3; // Number of tokens in between arguments.
      if (p != null) {
        for (int i = 0; i < p.getChildCount(); i += SPACE_PER_ARG) {
          String varDatatype = p.getChild(i).getText();
          String varID = p.getChild(i + 1).getText();
          args.put(varID, varDatatype);
        }
      }

      // We DO NOT add this to the tree since a prototype is just a forward
      // declaration for the symbol table!
      LCFunctionPrototypeNode prototypeNode = new LCFunctionPrototypeNode(ctx, this.symbolTable, id, retType,
          storageClass, args);

      this.syntaxTree.clearFlags();
    }
  }

  /**
   * Function call context exit.
   */
  @Override
  public void exitFunctionCallParameters(LittleCParser.FunctionCallParametersContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
    // Build the list, then pass it to the arg node.
    LinkedList<LCSyntaxTree> argsList = new LinkedList<>();
    for (int i = 0; i < ctx.expr().size(); i++) {
      ExprContext exprCtx = ctx.expr(i);
      LCSyntaxTree param = this.values.get(exprCtx);
      argsList.add(param);
    }

    LCFunctionArgsListNode fnArgsList = new LCFunctionArgsListNode(symbolTable, argsList);
    this.values.put(ctx, fnArgsList);
  }

  /**
   * Function declaration listener. A function declaration is distinct from a
   * prototype.
   */
  @Override
  public void enterFunctionDeclaration(LittleCParser.FunctionDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.ID() != null) {
      String id = ctx.ID().getText();
      String storageClass = LCUtilities.getStorageClassType(ctx.EXTERN(), ctx.STATIC());
      String retType = null;

      if (ctx.INT() != null) {
        retType = "int";
        this.syntaxTree.setFlags(LCMasks.RETURN_INT_MASK);
      } else if (ctx.CHAR() != null) {
        retType = "char";
        this.syntaxTree.setFlags(LCMasks.RETURN_CHAR_MASK);
      } else if (ctx.VOID() != null) {
        retType = "void";
        this.syntaxTree.setFlags(LCMasks.RETURN_VOID_MASK);
      } else {
        this.syntaxTree.printError(ctx, "required return type is unspecified.");
        return;
      }

      // The LinkedHashMap contains data types and IDs. Since we really only care
      // about the data type (but we have to store the IDs for the parse tree), and
      // the IDs must be unique, IDs are the key, and data types are the value. We use
      // a LinkedHashMap so the IDs are stored the same as they are entered.
      LinkedHashMap<String, String> args = new LinkedHashMap<String, String>();
      RuleFunctionDeclarationParametersContext p = ctx.ruleFunctionDeclarationParameters(0);
      final int SPACE_PER_ARG = 3; // Number of tokens in between arguments.
      if (p != null) {
        for (int i = 0; i < p.getChildCount(); i += SPACE_PER_ARG) {
          String varDatatype = p.getChild(i).getText();
          String varID = p.getChild(i + 1).getText();
          args.put(varID, varDatatype);
        }
      }

      // We need to create a new LCSyntaxTree to add to the fnDefNode so it makes a
      // new scope.
      LCSyntaxTree newScope = new LCSyntaxTree();
      LCFunctionDefinitionNode fnDefNode = new LCFunctionDefinitionNode(ctx, this.symbolTable, id, retType,
          storageClass, args, newScope);
      this.values.put(ctx, fnDefNode);
      this.syntaxTree.addChild(fnDefNode);

      // We push the current syntaxtree for traversal to the stack so we can save its
      // context.
      this.syntaxTreeScopes.push(this.syntaxTree);

      // Set the scope of the syntax tree to be this new one so variables can easily
      // add to it.
      this.syntaxTree = newScope;
    }
  }

  /**
   * Exit function declaration context listener. The return verification is done
   * here (i.e. if a return statement is required, it is checked in this block).
   * The current environment in the symbol table stack is popped, and the stack
   * for the SyntaxTree nodes is reset.
   */
  @Override
  public void exitFunctionDeclaration(LittleCParser.FunctionDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // Check the return type and verify that it exists if we have a non-void
    // function.
    if ((this.syntaxTree.getFlags() & LCMasks.RETURN_VOID_MASK) == 0) {
      int seqSize = this.syntaxTree.getChildren().size();

      // If we don't have any children in the tree and we have a return type,
      // we throw an error.
      if (this.syntaxTree.getChildren().isEmpty()) {
        this.syntaxTree.printError(ctx, "missing required return statement at end of function " + ctx.ID() + ".");
        return;
      }

      LCSyntaxTree lastChild = this.syntaxTree.getChildren().get(seqSize - 1);

      // Case 1: If our last child is an if/else if chain, then BOTH have to have
      // returns.
      if (lastChild.getLabel().equals("IF")) {
        int ifSize = lastChild.getChildren().size();

        // If it's two then we have no else chain and we're already screwed.
        if (ifSize == 2) {
          this.syntaxTree.printError(ctx, "missing required return statement outside if in function " + ctx.ID() + ".");
          return;
        }

        // Grab the children making the if/else chain.
        // This is ALWAYS only the if statement.
        LCSyntaxTree ifChild = lastChild.getChildren().get(1);

        // This can be the single else, or a giant chain of else/ifs.
        LCSyntaxTree elseChild = lastChild.getChildren().get(2);

        // Now we can check if BOTH the if and else bodies have returns everywhere.
        boolean hasReturn = LCUtilities.hasReturn(ifChild) && LCUtilities.hasReturn(elseChild);
        if (!hasReturn) {
          this.syntaxTree.printError(ctx,
              "missing required return statement in if/else block in function " + ctx.ID() + ".");
        }

      }
      // Case 2: In this event, the last statement HAS to be a return.
      else if (!lastChild.getLabel().equals("RETURN")) {
        this.syntaxTree.printError(ctx, "missing required return statement at end of function " + ctx.ID() + ".");
      }
    }

    // Removes the current environment from the stack and the syntax tree scope is
    // appended back to the main tree.
    this.symbolTable.popEnvironment();
    this.syntaxTree = this.syntaxTreeScopes.pop();
    this.syntaxTree.clearFlags();
  }

  /**
   * Function call enter context.
   */
  @Override
  public void enterFunctionCall(LittleCParser.FunctionCallContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    String id = ctx.ID().getText();

    // If the function call is undefined.
    if (!symbolTable.hasSymbol(id)) {
      this.syntaxTree.printError(ctx, "function " + id + " definition not found; forward declaration not found.");
      return;
    }

    // If the symbol itself is defined but it's a variable then we can't use it.
    else if (symbolTable.hasSymbol(id) && symbolTable.getSymbolEntry(id).getType().equals("VAR")) {
      this.syntaxTree.printError(ctx, id + " is a variable and cannot be used as a function identifier.");
      return;
    }

    this.syntaxTree.setFlags(LCMasks.FUNCTION_CALL_MASK);
    this.functionScopeCount++;
  }

  /**
   * Function call exit listener.
   */
  @Override
  public void exitFunctionCall(LittleCParser.FunctionCallContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    this.functionScopeCount--;

    String fnID = ctx.ID().getText();

    // Once we're out of the function call itself, we can actually put this node in
    // the tree and the map. This gets the function call parameters. If this is
    // null, we have no parameters.
    LCFunctionArgsListNode argsListNode = (LCFunctionArgsListNode) this.values.get(ctx.ruleFunctionCallParameters());
    LCFunctionCallNode fnCallNode = new LCFunctionCallNode(ctx, this.symbolTable, fnID, argsListNode);
    this.values.put(ctx, fnCallNode);

    // If we are not trying to assign the function to a variable (lvalue) AND we're
    // in the outer-most function (for composite function calls) AND we're not in a
    // return call, we can add it to the big tree.
    if (LCUtilities.isEveryFlagDisabled(this.syntaxTree, LCMasks.ASSIGN_MASK, LCMasks.RETURN_MASK, LCMasks.COND_MASK)
        && (this.functionScopeCount == 0)) {
      this.syntaxTree.addChild(fnCallNode);
    }

    this.syntaxTree.turnOffFlags(LCMasks.FUNCTION_CALL_MASK);

  }

  /**
   * Return statement enter context.
   */
  @Override
  public void enterReturnStatement(LittleCParser.ReturnStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    this.syntaxTree.setFlags(LCMasks.RETURN_MASK);
  }

  /**
   * Return statement exit context. We do the type checking and check the flags
   * set by the function declaration listener listener.
   */
  @Override
  public void exitReturnStatement(LittleCParser.ReturnStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    LCSyntaxTree retExpr = this.values.get(ctx.expr());
    String fnRetType = "";

    // Check the return type of the function that we're in to make sure it matches
    // the expression that we want to return.
    if ((this.syntaxTree.getFlags() & LCMasks.RETURN_INT_MASK) != 0) {
      fnRetType = "int";
    } else if ((this.syntaxTree.getFlags() & LCMasks.RETURN_CHAR_MASK) != 0) {
      fnRetType = "char";
    } else {
      fnRetType = "void";
    }

    // If we have an expression, then we need to check the types. If they match, we
    // create the correct node and send its on its way. Otherwise, we print a type
    // mismatch error. If we're in a void fn, we print the appropriate error.
    if (ctx.expr() != null) {
      if (!retExpr.getType().equals(fnRetType)) {
        if (!fnRetType.equals("void")) {
          this.syntaxTree.printError(ctx,
              "function expects return type of " + fnRetType + " but got " + retExpr.getType() + ".");
          return;
        } else {
          this.syntaxTree.printError(ctx, "cannot return value in void function.");
          return;
        }
      }
    }
    
    // If the expression is null, then we should be in a void method. If not, we
    // throw an error.
    else {
      if (!fnRetType.equals("void")) {
        this.syntaxTree.printError(ctx, "cannot have a blank return expression in non-void function.");
        return;
      }
    }

    LCReturnStatementNode returnNode = new LCReturnStatementNode(ctx, retExpr);
    this.values.put(ctx, returnNode);
    this.syntaxTree.addChild(returnNode);
    this.syntaxTree.turnOffFlags(LCMasks.RETURN_MASK);
  }

  /**
   * Assignment statement node enter context; we set the flag to tell other nested
   * statements that we don't want to add this twice (to things like for loops,
   * returns, etc.).
   */
  @Override
  public void enterAssignStatement(LittleCParser.AssignStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // Explained above.
    this.syntaxTree.setFlags(LCMasks.ASSIGN_MASK);
    this.assignScopeCount++;
  }

  /**
   * Assignment statement exit context listener. All type-checking is handled
   * inside the node itself, but id existence is verified here.
   */
  @Override
  public void exitAssignStatement(LittleCParser.AssignStatementContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    String id = ctx.ID().getText();

    LCSyntaxTree rvalue = null;
    LCSyntaxTree assignNode = null;

    // Fortunately, there are only five possibilities of how to assign something to
    // a node and they're all previously declared things in the map!
    if (!this.symbolTable.hasSymbol(id)) {
      this.syntaxTree.printError(ctx, "variable " + id + " is not previously declared.");
      return;
    }

    String lvalueType = this.symbolTable.getSymbolEntry(id).getVarType();

    // If there are two expressions, this means an array was created (or we tried to
    // use a non-array as an array). The second expression is the one we want to assign.
    if (ctx.expr().size() == 2) {
      // If we dereference the array, then it has a "pseudotype" of whatever type of
      // array it is. This suggests that we can't do something like int x[5]; x = 5;
      // But we can do x[0] = 5;
      if (!this.symbolTable.getSymbolEntry(id).getVarType().contains("[")
          && !this.symbolTable.getSymbolEntry(id).getVarType().contains("]")) {
        this.syntaxTree.printError(ctx, "cannot treat non-array " + id + " as array.");
        return;
      }

      // When we're in here, this means that we HAVE to use an array; that's our
      // invariant.
      String arrType = LCUtilities.getArrayType(lvalueType);

      // We're assigning either a term or an expression.
      if (ctx.expr() != null) {
        rvalue = this.values.get(ctx.expr(1));
      } else if (ctx.term() != null) {
        rvalue = this.values.get(ctx.term());
      }

      // We need to create the array identifier, reference, and then the assignment
      // node.
      LCVariableIdentifierNode arrayIdentifier = new LCVariableIdentifierNode(ctx, symbolTable, id, lvalueType);
      LCArrayIndexNode arrayReference = new LCArrayIndexNode(ctx, arrType, arrayIdentifier,
          this.values.get(ctx.expr(0)));
      assignNode = new LCAssignmentNode(ctx, this.symbolTable, id, lvalueType, arrayReference, rvalue);
    } else {
      // If we're not using an array, we're either using a term
      // or another expression in the assignment.
      if (ctx.expr(0) != null) {
        rvalue = this.values.get(ctx.expr(0));
      } else if (ctx.term() != null) {
        rvalue = this.values.get(ctx.term());
      } else if (ctx.ruleAssignStatement() != null) {
        rvalue = this.values.get(ctx.ruleAssignStatement());
      }

      assignNode = new LCAssignmentNode(ctx, this.symbolTable, id, lvalueType, rvalue);
    }

    // If we're not inside a conditional or nested expression, then
    // we can add this to the tree.
    if (LCUtilities.isEveryFlagDisabled(this.syntaxTree, LCMasks.EXPR_ASSIGN_MASK, LCMasks.COND_MASK)
        && this.assignScopeCount == 1) {
      this.syntaxTree.addChild(assignNode);
    }

    this.assignScopeCount--;
    this.values.put(ctx, assignNode);
    this.syntaxTree.turnOffFlags(LCMasks.ASSIGN_MASK);
  }

// ======================== END STATEMENTS ===============================//

// ======================== EXPRESSIONS ===============================//

  /**
   * Term inside expression enter context.
   */
  @Override
  public void enterExprTerm(LittleCParser.ExprTermContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
    // We either have an ID or a literal. We first check for an ID.
    if (ctx.term() != null) {
      if (ctx.term().ID() != null) {
        String id = ctx.term().ID().getText();
        if (this.symbolTable.hasSymbol(id)) {
          String varType = this.symbolTable.getSymbolEntry(id).getVarType();
          LCVariableIdentifierNode varIdentifier = new LCVariableIdentifierNode(ctx, symbolTable,
              ctx.term().ID().getText(), varType);
          this.values.put(ctx, varIdentifier);
        } else {
          this.syntaxTree.printError(ctx, "variable " + id + " was not previously declared.");
          return;
        }
      }
      // Check for the existence of a literal.
      else {
        LCConstantLiteralNode constantLiteral = null;
        if (ctx.term().INTLIT() != null) {
          String intLit = "";
          if (LCUtilities.isValidIntLiteral(ctx.term().INTLIT().getText())) {
            intLit = "" + LCUtilities.getDecodedIntLiteral(ctx.term().INTLIT().getText());
          } else {
            this.syntaxTree.printError(ctx, "cannot create an int literal.");
            return;            
          }
          constantLiteral = new LCConstantLiteralNode(ctx, intLit, "int");
        } else if (ctx.term().CHARLIT() != null) {
          String characterStr = ctx.term().CHARLIT().getText();
          String literalValue = String.valueOf((int) LCUtilities.getCharFromString(characterStr));
          constantLiteral = new LCConstantLiteralNode(ctx, literalValue, "char");
        } else if (ctx.term().STRINGLIT() != null) {
          constantLiteral = new LCConstantLiteralNode(ctx, ctx.term().STRINGLIT().getText(), "char[]");
        }

        this.values.put(ctx, constantLiteral);
      }
    }
  }

  /**
   * Term inside expression exit context.
   */
  @Override
  public void exitExprTerm(LittleCParser.ExprTermContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Calling a function inside an expression enter context.
   */
  @Override
  public void enterExprFunctionCall(LittleCParser.ExprFunctionCallContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Calling a function inside an expression exit context.
   */
  @Override
  public void exitExprFunctionCall(LittleCParser.ExprFunctionCallContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (this.values.get(ctx.ruleFunctionCall()) != null) {
      this.values.put(ctx, this.values.get(ctx.ruleFunctionCall()));
    } else {
      this.syntaxTree.printError(ctx, "cannot save parameters, did you call the function incorrectly?");
      return;
    }
  }

  /**
   * Expression pre operator enter context listener.
   */
  @Override
  public void enterExprPreOp(LittleCParser.ExprPreOpContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Expression pre operator exit context listener.
   */
  @Override
  public void exitExprPreOp(LittleCParser.ExprPreOpContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // First check if the symbol exists.
    String id = ctx.ID().getText();
    if (!this.symbolTable.hasSymbol(id)) {
      this.syntaxTree.printError(ctx, "variable " + id + " was not previously declared.");
      return;
    }

    String idType = this.symbolTable.getSymbolEntry(id).getVarType();
    String op = "";

    // Find the pre operator symbol that we're using.
    if (ctx.INC_OP() != null) {
      op = "PRE-INC";
    } else if (ctx.DEC_OP() != null) {
      op = "PRE-DEC";
    } else {
      this.syntaxTree.printError(ctx, op + " is an invalid pre-expression operator.");
      return;
    }

    LCSyntaxTree lvar = new LCVariableIdentifierNode(ctx, this.symbolTable, id, idType);

    // If we have an expression that means we're using an array. Arrays are
    // l-values! 
    if (ctx.expr() != null) {
      if (LCUtilities.isTypeArray(idType)) {
        idType = LCUtilities.getArrayType(idType);
        lvar = new LCArrayIndexNode(ctx, idType, lvar, this.values.get(ctx.expr()));
      }
    } else {
      // If the expression is null and we're on an array, that means we're 
      // not using an AIDX node.
      if (lvar.isArray()) {
        this.syntaxTree.printError(ctx, "cannot use " + id + " as an array l-value for this prefix unary operator.");
        return;
      }
    }

    LCPrePostOperatorNode prePostOp = new LCPrePostOperatorNode(ctx, symbolTable, op, idType, lvar);

    // If we're not in a function and we're not in a assign statement,
    // then we can add the child. It's redundant otherwise.
    if (LCUtilities.isEveryFlagDisabled(this.syntaxTree, LCMasks.FUNCTION_CALL_MASK, LCMasks.ASSIGN_MASK,
        LCMasks.COND_MASK, LCMasks.RETURN_MASK)) {
      this.syntaxTree.addChild(prePostOp);
    }

    this.values.put(ctx, prePostOp);
  }

  /**
   * Expression post operator enter context listener.
   */
  @Override
  public void enterExprPostOp(LittleCParser.ExprPostOpContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Expression post operator exit context listener. These are only used on
   * lvalues and cannot be used on literals or expressions that produce literals.
   */
  @Override
  public void exitExprPostOp(LittleCParser.ExprPostOpContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // First check if the symbol exists.
    String id = ctx.ID().getText();
    if (!this.symbolTable.hasSymbol(id)) {
      this.syntaxTree.printError(ctx, "variable " + id + " was not previously declared.");
      return;
    }

    String idType = this.symbolTable.getSymbolEntry(id).getVarType();
    String op = "";

    // Find the post operator symbol that we're using.
    if (ctx.INC_OP() != null) {
      op = "POST-INC";
    } else if (ctx.DEC_OP() != null) {
      op = "POST-DEC";
    } else {
      this.syntaxTree.printError(ctx, op + " is an invalid post-expression operator.");
      return;
    }

    LCSyntaxTree lvar = new LCVariableIdentifierNode(ctx, this.symbolTable, id, idType);

    // If we have an expression that means we're using an array. Arrays are
    // l-values!
    if (ctx.expr() != null) {
      if (LCUtilities.isTypeArray(idType)) {
        idType = LCUtilities.getArrayType(idType);
        lvar = new LCArrayIndexNode(ctx, idType, lvar, this.values.get(ctx.expr()));
      }
    } else {
      // If the expression is null and we're on an array, that means we're 
      // not using an AIDX node.
      if (lvar.isArray()) {
        this.syntaxTree.printError(ctx, "cannot use " + id + " as an array l-value for this postfix unary operator.");
        return;
      }
    }

    LCPrePostOperatorNode prePostOp = new LCPrePostOperatorNode(ctx, symbolTable, op, idType, lvar);

    // If we're not in a function and we're not in a assign statement,
    // then we can add the child. It's redundant otherwise.
    if (LCUtilities.isEveryFlagDisabled(this.syntaxTree, LCMasks.FUNCTION_CALL_MASK, LCMasks.ASSIGN_MASK,
        LCMasks.COND_MASK, LCMasks.RETURN_MASK)) {
      this.syntaxTree.addChild(prePostOp);
    }

    this.values.put(ctx, prePostOp);
  }

  /**
   * Expression unary operator enter context. Unary operators are only present in
   * expressions so we're good.
   */
  @Override
  public void enterExprUnary(LittleCParser.ExprUnaryContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Expression unary operator exit context. Unary operators are only present in
   * expressions so we're good. Checks are done to make sure that appropriate
   * operators are used (for instance, the size operator is only used on arrays).
   */
  @Override
  public void exitExprUnary(LittleCParser.ExprUnaryContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // Get the right-hand expression.
    LCSyntaxTree rexpr = this.values.get(ctx.expr());

    String op = null;
    String type = rexpr.getType();

    if (rexpr.isInteger() || rexpr.isChar()) {
      if (ctx.PLUS_OP() != null) {
        op = "+";
      } else if (ctx.MINUS_OP() != null) {
        op = "-";
      } else if (ctx.NOT() != null) {
        op = "!";
      } else if (ctx.BIT_NEG() != null) {
        op = "~";
      } else {
        this.syntaxTree.printError(ctx, "invalid unary operator for r-value expression of type " + type + ".");
        return;
      }
    } else if (rexpr.isArray()) {
      if (ctx.SIZE_OP() != null) {
        op = "#";
        type = "int"; // We have to change the type since it's different here.
      } else {
        this.syntaxTree.printError(ctx, "invalid unary operator for r-value expression of type " + type + ".");
        return;
      }
    }

    LCUnaryOperatorNode unaryOpNode = new LCUnaryOperatorNode(ctx, this.symbolTable, op, type, rexpr);

    this.values.put(ctx, unaryOpNode);
  }

  /**
   * Binary operator in expression enter context listener.
   */
  @Override
  public void enterExprBinaryOp(LittleCParser.ExprBinaryOpContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Binary operator in expression exit context listener. All operators correspond
   * to an appropriate lvalue and rvalue, meaning that they can only be used with
   * a specific data type. For the most part (in fact, for all parts), these are
   * ints.
   */
  @Override
  public void exitExprBinaryOp(LittleCParser.ExprBinaryOpContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    LCSyntaxTree lexpr = this.values.get(ctx.expr().get(0));
    LCSyntaxTree rexpr = this.values.get(ctx.expr().get(1));

    String op = null;

    /* If this is an arithmetic operator (where we CANNOT compare strings...) */
    /* A better way must be found... */
    if (hasBinaryOperator(ctx)) {

      boolean lStr = lexpr.isArray();
      boolean rStr = rexpr.isArray();

      if (lStr || rStr) {
        this.syntaxTree.printError(ctx, "cannot use binary operator on array datatype.");
        this.syntaxTree.setFlags(LCMasks.ERROR_MASK);
        return;
      }

      // Now actually get the flags and set the operator.
      op = getBinaryOperator(ctx);
      if (op == null) {
        this.syntaxTree.printError(ctx, "invalid binary operator.");
        return;
      }
    }

    LCBinaryOperatorNode binaryOpNode = new LCBinaryOperatorNode(ctx, this.symbolTable, op, lexpr, rexpr);

    this.values.put(ctx, binaryOpNode);
  }

  /**
   * Term enter context listener. A term is defined as a literal or an identifier
   * in an expression.
   */
  @Override
  public void enterTerm(LittleCParser.TermContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Term exit context listener. A term is defined as a literal or an identifier
   * in an expression.
   */
  @Override
  public void exitTerm(LittleCParser.TermContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    // We either have an ID or a literal. We first check for an ID.
    if (ctx.ID() != null) {
      String id = ctx.ID().getText();
      if (this.symbolTable.hasSymbol(id)) {
        String varType = this.symbolTable.getSymbolEntry(id).getVarType();
        LCVariableIdentifierNode varIdentifier = new LCVariableIdentifierNode(ctx, symbolTable, ctx.ID().getText(),
            varType);
        this.values.put(ctx, varIdentifier);
      } else {
        this.syntaxTree.printError(ctx, "variable " + id + " was not previously declared.");
        return;
      }
    }
    // Here we check for the existence of a literal.
    else {
      LCConstantLiteralNode constantLiteral = null;
      if (ctx.INTLIT() != null) {
        String intLit = "";
        if (LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
          intLit = "" + LCUtilities.getDecodedIntLiteral(ctx.INTLIT().getText());
        } else {
          this.syntaxTree.printError(ctx, "cannot create an int literal.");
          return;            
        }
        
        constantLiteral = new LCConstantLiteralNode(ctx, intLit, "int");
      } else if (ctx.CHARLIT() != null) {
        String characterStr = ctx.CHARLIT().getText();
        String literalValue = String.valueOf((int) LCUtilities.getCharFromString(characterStr));
        constantLiteral = new LCConstantLiteralNode(ctx, literalValue, "char");
      } else if (ctx.STRINGLIT() != null) {
        constantLiteral = new LCConstantLiteralNode(ctx, ctx.STRINGLIT().getText(), "char[]");
      }
      this.values.put(ctx, constantLiteral);
    }
  }

  /**
   * Expression parenthesis enter listener "(" <expr> ")".
   */
  public void enterExprParen(LittleCParser.ExprParenContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Expression parenthesis exit listener "(" <expr> ")".
   */
  public void exitExprParen(LittleCParser.ExprParenContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    this.values.put(ctx, this.values.get(ctx.expr()));
  }

  /**
   * Expression array reference enter listener (using an array in an expression).
   * For instance, foo = a[i] + bar;
   */
  @Override
  public void enterExprArray(LittleCParser.ExprArrayContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Expression array reference exit listener (using an array in an expression).
   * For instance, foo = a[i] + bar;
   * 
   * The exit listener gets the array type (int[], char[]), the backing element
   * type (int, char), and creates the indexing node.
   */
  @Override
  public void exitExprArray(LittleCParser.ExprArrayContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    String id = ctx.ID().getText();

    if (!this.symbolTable.hasSymbol(id)) {
      this.syntaxTree.printError(ctx, "array object was not previously declared.");
      return;
    }

    // Gets the array type and then extracts the type of array.
    String arrayType = this.symbolTable.getSymbolEntry(id).getVarType();
    String elementType = LCUtilities.getArrayType(arrayType);

    // Create the nodes for the identifier, the index expression, and the node
    // itself. Note that the array identifier is ONLY FOR SHOW.
    LCSyntaxTree arrayIdentifier = new LCVariableIdentifierNode(ctx, symbolTable, id, arrayType);
    LCSyntaxTree indexExpr = this.values.get(ctx.expr());

    LCArrayIndexNode arrayIndexNode = new LCArrayIndexNode(ctx, elementType, arrayIdentifier, indexExpr);

    this.values.put(ctx, arrayIndexNode);
  }

  /**
   * Enter expression assignment (e.g. a = a + (b = c);)
   */
  @Override
  public void enterExprAssign(LittleCParser.ExprAssignContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    this.syntaxTree.setFlags(LCMasks.EXPR_ASSIGN_MASK);
  }

  /**
   * Exiting expression assignment.
   */
  @Override
  public void exitExprAssign(LittleCParser.ExprAssignContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    this.values.put(ctx, this.values.get(ctx.ruleAssignStatement()));
    this.syntaxTree.turnOffFlags(LCMasks.EXPR_ASSIGN_MASK);
  }

// ======================== END EXPRESSIONS ===============================//

// ======================== DECLARATIONS ===============================//

  /**
   * Enter declaration for an integer variable.
   */
  @Override
  public void enterIntDeclaration(LittleCParser.IntDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Exit declaration for an integer variable.
   */
  @Override
  public void exitIntDeclaration(LittleCParser.IntDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.ID() != null) {
      String lValue = ctx.ID().getText();
      String storageClass = LCUtilities.getStorageClassType(ctx.EXTERN(), ctx.STATIC());
      Object literalValue = null;

      // If we're assigning to something, grab the literal value.
      if (ctx.INTLIT() != null) {
        if (LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
          literalValue = LCUtilities.getDecodedIntLiteral(ctx.INTLIT().getText());  
        } else {
          System.out.println(ctx.INTLIT().getText());
          this.syntaxTree.printError(ctx, "cannot create an int literal.");
          return;
        }
      } else if (ctx.CHARLIT() != null) {
        String characterStr = ctx.CHARLIT().getText();
        literalValue = (int) LCUtilities.getCharFromString(characterStr);
      }

      LCVariableDeclarationNode intDeclarationNode = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, "int",
          storageClass, literalValue);

      this.syntaxTree.addChild(intDeclarationNode);
      this.values.put(ctx, intDeclarationNode);
    }
  }

  /**
   * Exit declaration for an integer array context.
   */
  @Override
  public void enterIntArrayDeclaration(LittleCParser.IntArrayDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Enter declaration for an integer array context.
   */
  @Override
  public void exitIntArrayDeclaration(LittleCParser.IntArrayDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.ID() != null) {
      String lValue = ctx.ID().getText();
      String type = "int[" + ctx.INTLIT().getText() + "]";
      String storageClass = LCUtilities.getStorageClassType(ctx.EXTERN(), ctx.STATIC());
      Object literalValue = null;

      // We need to test to see if the size is valid or not. It doesn't matter where
      // we store it; it just needs to be valid.
      if (!LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
        this.syntaxTree.printError(ctx, "cannot create an int literal for array index.");
        return;
      }

      LCVariableDeclarationNode intArrayDeclaration = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, type,
          storageClass, literalValue);

      this.syntaxTree.addChild(intArrayDeclaration);
      this.values.put(ctx, intArrayDeclaration);
    }
  }

  /**
   * Enter int array reference declaration context.
   */
  @Override
  public void enterIntArrayRefDeclaration(LittleCParser.IntArrayRefDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Exit int array reference declaration context.
   */
  @Override
  public void exitIntArrayRefDeclaration(LittleCParser.IntArrayRefDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.ID() != null) {
      String lValue = ctx.ID().getText();
      String type = "int[]";
      String storageClass = LCUtilities.getStorageClassType(ctx.EXTERN(), ctx.STATIC());
      Object literalValue = null;

      LCVariableDeclarationNode intArrayRef = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, type,
          storageClass, literalValue);

      this.syntaxTree.addChild(intArrayRef);
      this.values.put(ctx, intArrayRef);
    }
  }

  /**
   * Enter declaration for a char variable.
   */
  @Override
  public void enterCharDeclaration(LittleCParser.CharDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Exit declaration for a char variable.
   */
  @Override
  public void exitCharDeclaration(LittleCParser.CharDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.ID() != null) {
      String lValue = ctx.ID().getText();
      String storageClass = LCUtilities.getStorageClassType(ctx.EXTERN(), ctx.STATIC());
      Object literalValue = null;

      // If we're assigning to something, grab the literal value.
      if (ctx.CHARLIT() != null) {
        String characterStr = ctx.CHARLIT().getText();
        literalValue = (int) LCUtilities.getCharFromString(characterStr);
      }
      // We can have both int literals and char literals for chars.
      else if (ctx.INTLIT() != null) {
        if (LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
          literalValue = LCUtilities.getDecodedIntLiteral(ctx.INTLIT().getText());  
        } else {
          this.syntaxTree.printError(ctx, "cannot create an int literal.");
          return;
        }
      }

      LCVariableDeclarationNode charDeclarationNode = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue,
          "char", storageClass, literalValue);

      this.syntaxTree.addChild(charDeclarationNode);
      this.values.put(ctx, charDeclarationNode);
    }
  }

  /**
   * Enter declaration for a string literal (char array).
   */
  @Override
  public void enterStringDeclaration(LittleCParser.StringDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Exit declaration for a string literal (char array).
   */
  @Override
  public void exitStringDeclaration(LittleCParser.StringDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.ID() != null) {
      String lValue = ctx.ID().getText();
      String type = "char[" + ctx.INTLIT().getText() + "]";
      String storageClass = LCUtilities.getStorageClassType(ctx.EXTERN(), ctx.STATIC());
      Object literalValue = null;

      // If we're assigning to something, grab the literal value.
      if (ctx.STRINGLIT() != null) {
        literalValue = ctx.STRINGLIT().getText();
      }

      // We need to test to see if the size is valid or not. It doesn't matter where
      // we store it; it just needs to be valid.
      if (!LCUtilities.isValidIntLiteral(ctx.INTLIT().getText())) {
        this.syntaxTree.printError(ctx, "cannot create an int literal for array index.");
        return;
      }

      LCVariableDeclarationNode stringDeclarationNode = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue,
          type, storageClass, literalValue);

      this.syntaxTree.addChild(stringDeclarationNode);
      this.values.put(ctx, stringDeclarationNode);
    }
  }

  /**
   * Enter string (char[]) reference declaration context.
   */
  @Override
  public void enterStringRefDeclaration(LittleCParser.StringRefDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }
  }

  /**
   * Exit string (char[]) reference declaration context).
   */
  @Override
  public void exitStringRefDeclaration(LittleCParser.StringRefDeclarationContext ctx) {
    if (this.syntaxTree.hasError()) {
      return;
    }

    if (ctx.ID() != null) {
      String lValue = ctx.ID().getText();
      String type = "char[]";
      String storageClass = LCUtilities.getStorageClassType(ctx.EXTERN(), ctx.STATIC());
      Object literalValue = null;

      LCVariableDeclarationNode stringRef = new LCVariableDeclarationNode(ctx, this.symbolTable, lValue, type,
          storageClass, literalValue);

      this.syntaxTree.addChild(stringRef);
      this.values.put(ctx, stringRef);
    }
  }

  // ======================== END DECLARATIONS ===============================//

  /**
   * Returns a syntax tree after successful parsing.
   *
   * @return a syntax tree, or null if an error was detected.
   */
  public LCSyntaxTree getSyntaxTree() {
    if (this.syntaxTree.hasError()) {
      return null;
    }

    // If the main function doesn't exist then we can't continue.
    if (this.symbolTable.hasSymbol("main") && this.symbolTable.getSymbolEntry("main").getVarType().equals("void")) {
      return this.syntaxTree;
    } else {
      this.syntaxTree.printError(null, "Parsing error: void main function definition not found.");
      return null;
    }
  }

  /**
   * Returns the symbol table. Can be called at any time, but generally this will
   * be called after all parsing is complete to get the final symbol table
   * containing all global declarations.
   *
   * @return the symbol table
   */
  public SymbolTable getSymbolTable() {
    return this.symbolTable;
  }

  /**
   * Adds the default functions from LittleC to the global functions symbol table.
   */
  private void addDefaultGlobalFunctions() {
    /* Adds the prints function. */
    LinkedList<LCSyntaxTree> args = new LinkedList<>();
    args.add(new LCVariableIdentifierNode(null, symbolTable, "str", "char[]"));
    this.symbolTable.addSymbol("prints", new SymbolEntry("FNDEF", "void", "extern", args));
    args = new LinkedList<>();

    /* Adds the printd function. */
    args.add(new LCVariableIdentifierNode(null, symbolTable, "number", "int"));
    this.symbolTable.addSymbol("printd", new SymbolEntry("FNDEF", "void", "extern", args));
    args = new LinkedList<>();

    /* Adds the printc function. */
    args.add(new LCVariableIdentifierNode(null, symbolTable, "number", "char"));
    this.symbolTable.addSymbol("printc", new SymbolEntry("FNDEF", "void", "extern", args));
    args = new LinkedList<>();

    /* Adds the printf function. */
    args.add(new LCVariableIdentifierNode(null, symbolTable, "number", "float"));
    this.symbolTable.addSymbol("printf", new SymbolEntry("FNDEF", "void", "extern", args));
    args = new LinkedList<>();

    /* Adds the read() function. */
    this.symbolTable.addSymbol("read", new SymbolEntry("FNDEF", "int", "extern", args));
    args = new LinkedList<>();

    /* Adds the readc() function. */
    this.symbolTable.addSymbol("readc", new SymbolEntry("FNDEF", "char", "extern", args));
    args = new LinkedList<>();

    /* Adds the readf() function. */
    this.symbolTable.addSymbol("readf", new SymbolEntry("FNDEF", "float", "extern", args));
    args = new LinkedList<>();

    /* Add the readline() function. */
    args.add(new LCVariableIdentifierNode(null, symbolTable, "str", "char[]"));
    this.symbolTable.addSymbol("readline", new SymbolEntry("FNDEF", "void", "extern", args));
  }
  
  /**
   * Returns whether or not there is a non-null binary operator node in the ExprBinaryOpContext
   * object.
   * 
   * @param ctx ExprBinaryOpContext object.
   * 
   * @return true if there is a non-null node, false otherwise.
   */
  private boolean hasBinaryOperator(LittleCParser.ExprBinaryOpContext ctx) {
    return (ctx.PLUS_OP() != null || ctx.MINUS_OP() != null || ctx.MULTIPLY_OP() != null || ctx.DIVIDE_OP() != null
        || ctx.MODULO_OP() != null || ctx.GREATER_EQ_CMP() != null || ctx.GREATER_THAN_CMP() != null
        || ctx.LESS_EQ_CMP() != null || ctx.LESS_THAN_CMP() != null || ctx.EQUAL_CMP() != null || ctx.BIT_XOR() != null
        || ctx.BIT_AND() != null || ctx.BIT_SHIFT_LEFT() != null || ctx.BIT_SHIFT_RIGHT() != null
        || ctx.BIT_OR() != null || ctx.NOT_EQUAL_CMP() != null || ctx.AND() != null || ctx.OR() != null);
  }
  
  /**
   * Returns the appropriate string binary operator in the ExprBinaryOpContext.
   * We have to painstakingly check each node for "nullness".
   * 
   * @param ctx - ExprBinaryOpContext object.
   * 
   * @return string operator if there is a non-null one, null otherwise.
   */
  private String getBinaryOperator(LittleCParser.ExprBinaryOpContext ctx) {
    if (ctx.PLUS_OP() != null) {
      return "+";
    } else if (ctx.MINUS_OP() != null) {
      return "-";
    } else if (ctx.MULTIPLY_OP() != null) {
      return "*";
    } else if (ctx.DIVIDE_OP() != null) {
      return "/";
    } else if (ctx.MODULO_OP() != null) {
      return "%"; 
    } else if (ctx.AND() != null) {
      return "&&";
    } else if (ctx.OR() != null) {
      return "||";
    } else if (ctx.BIT_AND() != null) {
      return "&";
    } else if (ctx.BIT_OR() != null) {
      return "|";
    } else if (ctx.BIT_XOR() != null) {
      return "^";
    } else if (ctx.BIT_SHIFT_LEFT() != null) {
      return "<<";
    } else if (ctx.BIT_SHIFT_RIGHT() != null) {
      return ">>";
    } else if (ctx.GREATER_EQ_CMP() != null) {
      return ">=";
    } else if (ctx.GREATER_THAN_CMP() != null) {
      return ">";
    } else if (ctx.LESS_EQ_CMP() != null) {
      return "<=";
    } else if (ctx.LESS_THAN_CMP() != null) {
      return "<";
    } else if (ctx.EQUAL_CMP() != null) {
      return "==";
    } else if (ctx.NOT_EQUAL_CMP() != null) {
      return "!=";
    }
    return null;
  }
}
//Why is Dr. Tate so evilllllllllllllllllllllllll
